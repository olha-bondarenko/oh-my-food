{"ast":null,"code":"'use strict';\n/**\n * @license Angular v14.0.0-next.5\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @fileoverview\n * @suppress {globalThis}\n */\n\nconst NEWLINE = '\\n';\nconst IGNORE_FRAMES = {};\nconst creationTrace = '__creationTrace__';\nconst ERROR_TAG = 'STACKTRACE TRACKING';\nconst SEP_TAG = '__SEP_TAG__';\nlet sepTemplate = SEP_TAG + '@[native]';\n\nclass LongStackTrace {\n  constructor() {\n    this.error = getStacktrace();\n    this.timestamp = new Date();\n  }\n\n}\n\nfunction getStacktraceWithUncaughtError() {\n  return new Error(ERROR_TAG);\n}\n\nfunction getStacktraceWithCaughtError() {\n  try {\n    throw getStacktraceWithUncaughtError();\n  } catch (err) {\n    return err;\n  }\n} // Some implementations of exception handling don't create a stack trace if the exception\n// isn't thrown, however it's faster not to actually throw the exception.\n\n\nconst error = getStacktraceWithUncaughtError();\nconst caughtError = getStacktraceWithCaughtError();\nconst getStacktrace = error.stack ? getStacktraceWithUncaughtError : caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError;\n\nfunction getFrames(error) {\n  return error.stack ? error.stack.split(NEWLINE) : [];\n}\n\nfunction addErrorStack(lines, error) {\n  let trace = getFrames(error);\n\n  for (let i = 0; i < trace.length; i++) {\n    const frame = trace[i]; // Filter out the Frames which are part of stack capturing.\n\n    if (!IGNORE_FRAMES.hasOwnProperty(frame)) {\n      lines.push(trace[i]);\n    }\n  }\n}\n\nfunction renderLongStackTrace(frames, stack) {\n  const longTrace = [stack ? stack.trim() : ''];\n\n  if (frames) {\n    let timestamp = new Date().getTime();\n\n    for (let i = 0; i < frames.length; i++) {\n      const traceFrames = frames[i];\n      const lastTime = traceFrames.timestamp;\n      let separator = `____________________Elapsed ${timestamp - lastTime.getTime()} ms; At: ${lastTime}`;\n      separator = separator.replace(/[^\\w\\d]/g, '_');\n      longTrace.push(sepTemplate.replace(SEP_TAG, separator));\n      addErrorStack(longTrace, traceFrames.error);\n      timestamp = lastTime.getTime();\n    }\n  }\n\n  return longTrace.join(NEWLINE);\n} // if Error.stackTraceLimit is 0, means stack trace\n// is disabled, so we don't need to generate long stack trace\n// this will improve performance in some test(some test will\n// set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\n\n\nfunction stackTracesEnabled() {\n  // Cast through any since this property only exists on Error in the nodejs\n  // typings.\n  return Error.stackTraceLimit > 0;\n}\n\nZone['longStackTraceZoneSpec'] = {\n  name: 'long-stack-trace',\n  longStackTraceLimit: 10,\n  // add a getLongStackTrace method in spec to\n  // handle handled reject promise error.\n  getLongStackTrace: function (error) {\n    if (!error) {\n      return undefined;\n    }\n\n    const trace = error[Zone.__symbol__('currentTaskTrace')];\n\n    if (!trace) {\n      return error.stack;\n    }\n\n    return renderLongStackTrace(trace, error.stack);\n  },\n  onScheduleTask: function (parentZoneDelegate, currentZone, targetZone, task) {\n    if (stackTracesEnabled()) {\n      const currentTask = Zone.currentTask;\n      let trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];\n      trace = [new LongStackTrace()].concat(trace);\n\n      if (trace.length > this.longStackTraceLimit) {\n        trace.length = this.longStackTraceLimit;\n      }\n\n      if (!task.data) task.data = {};\n\n      if (task.type === 'eventTask') {\n        // Fix issue https://github.com/angular/zone.js/issues/1195,\n        // For event task of browser, by default, all task will share a\n        // singleton instance of data object, we should create a new one here\n        // The cast to `any` is required to workaround a closure bug which wrongly applies\n        // URL sanitization rules to .data access.\n        task.data = Object.assign({}, task.data);\n      }\n\n      task.data[creationTrace] = trace;\n    }\n\n    return parentZoneDelegate.scheduleTask(targetZone, task);\n  },\n  onHandleError: function (parentZoneDelegate, currentZone, targetZone, error) {\n    if (stackTracesEnabled()) {\n      const parentTask = Zone.currentTask || error.task;\n\n      if (error instanceof Error && parentTask) {\n        const longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);\n\n        try {\n          error.stack = error.longStack = longStack;\n        } catch (err) {}\n      }\n    }\n\n    return parentZoneDelegate.handleError(targetZone, error);\n  }\n};\n\nfunction captureStackTraces(stackTraces, count) {\n  if (count > 0) {\n    stackTraces.push(getFrames(new LongStackTrace().error));\n    captureStackTraces(stackTraces, count - 1);\n  }\n}\n\nfunction computeIgnoreFrames() {\n  if (!stackTracesEnabled()) {\n    return;\n  }\n\n  const frames = [];\n  captureStackTraces(frames, 2);\n  const frames1 = frames[0];\n  const frames2 = frames[1];\n\n  for (let i = 0; i < frames1.length; i++) {\n    const frame1 = frames1[i];\n\n    if (frame1.indexOf(ERROR_TAG) == -1) {\n      let match = frame1.match(/^\\s*at\\s+/);\n\n      if (match) {\n        sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';\n        break;\n      }\n    }\n  }\n\n  for (let i = 0; i < frames1.length; i++) {\n    const frame1 = frames1[i];\n    const frame2 = frames2[i];\n\n    if (frame1 === frame2) {\n      IGNORE_FRAMES[frame1] = true;\n    } else {\n      break;\n    }\n  }\n}\n\ncomputeIgnoreFrames();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nclass ProxyZoneSpec {\n  constructor(defaultSpecDelegate = null) {\n    this.defaultSpecDelegate = defaultSpecDelegate;\n    this.name = 'ProxyZone';\n    this._delegateSpec = null;\n    this.properties = {\n      'ProxyZoneSpec': this\n    };\n    this.propertyKeys = null;\n    this.lastTaskState = null;\n    this.isNeedToTriggerHasTask = false;\n    this.tasks = [];\n    this.setDelegate(defaultSpecDelegate);\n  }\n\n  static get() {\n    return Zone.current.get('ProxyZoneSpec');\n  }\n\n  static isLoaded() {\n    return ProxyZoneSpec.get() instanceof ProxyZoneSpec;\n  }\n\n  static assertPresent() {\n    if (!ProxyZoneSpec.isLoaded()) {\n      throw new Error(`Expected to be running in 'ProxyZone', but it was not found.`);\n    }\n\n    return ProxyZoneSpec.get();\n  }\n\n  setDelegate(delegateSpec) {\n    const isNewDelegate = this._delegateSpec !== delegateSpec;\n    this._delegateSpec = delegateSpec;\n    this.propertyKeys && this.propertyKeys.forEach(key => delete this.properties[key]);\n    this.propertyKeys = null;\n\n    if (delegateSpec && delegateSpec.properties) {\n      this.propertyKeys = Object.keys(delegateSpec.properties);\n      this.propertyKeys.forEach(k => this.properties[k] = delegateSpec.properties[k]);\n    } // if a new delegateSpec was set, check if we need to trigger hasTask\n\n\n    if (isNewDelegate && this.lastTaskState && (this.lastTaskState.macroTask || this.lastTaskState.microTask)) {\n      this.isNeedToTriggerHasTask = true;\n    }\n  }\n\n  getDelegate() {\n    return this._delegateSpec;\n  }\n\n  resetDelegate() {\n    this.getDelegate();\n    this.setDelegate(this.defaultSpecDelegate);\n  }\n\n  tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone) {\n    if (this.isNeedToTriggerHasTask && this.lastTaskState) {\n      // last delegateSpec has microTask or macroTask\n      // should call onHasTask in current delegateSpec\n      this.isNeedToTriggerHasTask = false;\n      this.onHasTask(parentZoneDelegate, currentZone, targetZone, this.lastTaskState);\n    }\n  }\n\n  removeFromTasks(task) {\n    if (!this.tasks) {\n      return;\n    }\n\n    for (let i = 0; i < this.tasks.length; i++) {\n      if (this.tasks[i] === task) {\n        this.tasks.splice(i, 1);\n        return;\n      }\n    }\n  }\n\n  getAndClearPendingTasksInfo() {\n    if (this.tasks.length === 0) {\n      return '';\n    }\n\n    const taskInfo = this.tasks.map(task => {\n      const dataInfo = task.data && Object.keys(task.data).map(key => {\n        return key + ':' + task.data[key];\n      }).join(',');\n      return `type: ${task.type}, source: ${task.source}, args: {${dataInfo}}`;\n    });\n    const pendingTasksInfo = '--Pending async tasks are: [' + taskInfo + ']'; // clear tasks\n\n    this.tasks = [];\n    return pendingTasksInfo;\n  }\n\n  onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec) {\n    if (this._delegateSpec && this._delegateSpec.onFork) {\n      return this._delegateSpec.onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec);\n    } else {\n      return parentZoneDelegate.fork(targetZone, zoneSpec);\n    }\n  }\n\n  onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source) {\n    if (this._delegateSpec && this._delegateSpec.onIntercept) {\n      return this._delegateSpec.onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source);\n    } else {\n      return parentZoneDelegate.intercept(targetZone, delegate, source);\n    }\n  }\n\n  onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n    this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n    if (this._delegateSpec && this._delegateSpec.onInvoke) {\n      return this._delegateSpec.onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source);\n    } else {\n      return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n    }\n  }\n\n  onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n    if (this._delegateSpec && this._delegateSpec.onHandleError) {\n      return this._delegateSpec.onHandleError(parentZoneDelegate, currentZone, targetZone, error);\n    } else {\n      return parentZoneDelegate.handleError(targetZone, error);\n    }\n  }\n\n  onScheduleTask(parentZoneDelegate, currentZone, targetZone, task) {\n    if (task.type !== 'eventTask') {\n      this.tasks.push(task);\n    }\n\n    if (this._delegateSpec && this._delegateSpec.onScheduleTask) {\n      return this._delegateSpec.onScheduleTask(parentZoneDelegate, currentZone, targetZone, task);\n    } else {\n      return parentZoneDelegate.scheduleTask(targetZone, task);\n    }\n  }\n\n  onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {\n    if (task.type !== 'eventTask') {\n      this.removeFromTasks(task);\n    }\n\n    this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n    if (this._delegateSpec && this._delegateSpec.onInvokeTask) {\n      return this._delegateSpec.onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs);\n    } else {\n      return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n    }\n  }\n\n  onCancelTask(parentZoneDelegate, currentZone, targetZone, task) {\n    if (task.type !== 'eventTask') {\n      this.removeFromTasks(task);\n    }\n\n    this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n    if (this._delegateSpec && this._delegateSpec.onCancelTask) {\n      return this._delegateSpec.onCancelTask(parentZoneDelegate, currentZone, targetZone, task);\n    } else {\n      return parentZoneDelegate.cancelTask(targetZone, task);\n    }\n  }\n\n  onHasTask(delegate, current, target, hasTaskState) {\n    this.lastTaskState = hasTaskState;\n\n    if (this._delegateSpec && this._delegateSpec.onHasTask) {\n      this._delegateSpec.onHasTask(delegate, current, target, hasTaskState);\n    } else {\n      delegate.hasTask(target, hasTaskState);\n    }\n  }\n\n} // Export the class so that new instances can be created with proper\n// constructor params.\n\n\nZone['ProxyZoneSpec'] = ProxyZoneSpec;\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nclass SyncTestZoneSpec {\n  constructor(namePrefix) {\n    this.runZone = Zone.current;\n    this.name = 'syncTestZone for ' + namePrefix;\n  }\n\n  onScheduleTask(delegate, current, target, task) {\n    switch (task.type) {\n      case 'microTask':\n      case 'macroTask':\n        throw new Error(`Cannot call ${task.source} from within a sync test.`);\n\n      case 'eventTask':\n        task = delegate.scheduleTask(target, task);\n        break;\n    }\n\n    return task;\n  }\n\n} // Export the class so that new instances can be created with proper\n// constructor params.\n\n\nZone['SyncTestZoneSpec'] = SyncTestZoneSpec;\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nZone.__load_patch('jasmine', (global, Zone, api) => {\n  const __extends = function (d, b) {\n    for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  }; // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n  // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n\n\n  if (!Zone) throw new Error('Missing: zone.js');\n\n  if (typeof jest !== 'undefined') {\n    // return if jasmine is a light implementation inside jest\n    // in this case, we are running inside jest not jasmine\n    return;\n  }\n\n  if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n    return;\n  }\n\n  jasmine['__zone_patch__'] = true;\n  const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n  const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n  if (!SyncTestZoneSpec) throw new Error('Missing: SyncTestZoneSpec');\n  if (!ProxyZoneSpec) throw new Error('Missing: ProxyZoneSpec');\n  const ambientZone = Zone.current; // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n  // error if any asynchronous operations are attempted inside of a `describe` but outside of\n  // a `beforeEach` or `it`.\n\n  const syncZone = ambientZone.fork(new SyncTestZoneSpec('jasmine.describe'));\n  const symbol = Zone.__symbol__; // whether patch jasmine clock when in fakeAsync\n\n  const disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true; // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n  // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also\n  // automatically disable the auto jump into fakeAsync feature\n\n  const enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock && (global[symbol('fakeAsyncPatchLock')] === true || global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true);\n  const ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n\n  if (!ignoreUnhandledRejection) {\n    const globalErrors = jasmine.GlobalErrors;\n\n    if (globalErrors && !jasmine[symbol('GlobalErrors')]) {\n      jasmine[symbol('GlobalErrors')] = globalErrors;\n\n      jasmine.GlobalErrors = function () {\n        const instance = new globalErrors();\n        const originalInstall = instance.install;\n\n        if (originalInstall && !instance[symbol('install')]) {\n          instance[symbol('install')] = originalInstall;\n\n          instance.install = function () {\n            const originalHandlers = process.listeners('unhandledRejection');\n            const r = originalInstall.apply(this, arguments);\n            process.removeAllListeners('unhandledRejection');\n\n            if (originalHandlers) {\n              originalHandlers.forEach(h => process.on('unhandledRejection', h));\n            }\n\n            return r;\n          };\n        }\n\n        return instance;\n      };\n    }\n  } // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n\n\n  const jasmineEnv = jasmine.getEnv();\n  ['describe', 'xdescribe', 'fdescribe'].forEach(methodName => {\n    let originalJasmineFn = jasmineEnv[methodName];\n\n    jasmineEnv[methodName] = function (description, specDefinitions) {\n      return originalJasmineFn.call(this, description, wrapDescribeInZone(specDefinitions));\n    };\n  });\n  ['it', 'xit', 'fit'].forEach(methodName => {\n    let originalJasmineFn = jasmineEnv[methodName];\n    jasmineEnv[symbol(methodName)] = originalJasmineFn;\n\n    jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n      arguments[1] = wrapTestInZone(specDefinitions);\n      return originalJasmineFn.apply(this, arguments);\n    };\n  });\n  ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(methodName => {\n    let originalJasmineFn = jasmineEnv[methodName];\n    jasmineEnv[symbol(methodName)] = originalJasmineFn;\n\n    jasmineEnv[methodName] = function (specDefinitions, timeout) {\n      arguments[0] = wrapTestInZone(specDefinitions);\n      return originalJasmineFn.apply(this, arguments);\n    };\n  });\n\n  if (!disablePatchingJasmineClock) {\n    // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n    // they can work properly in FakeAsyncTest\n    const originalClockFn = jasmine[symbol('clock')] = jasmine['clock'];\n\n    jasmine['clock'] = function () {\n      const clock = originalClockFn.apply(this, arguments);\n\n      if (!clock[symbol('patched')]) {\n        clock[symbol('patched')] = symbol('patched');\n        const originalTick = clock[symbol('tick')] = clock.tick;\n\n        clock.tick = function () {\n          const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n          }\n\n          return originalTick.apply(this, arguments);\n        };\n\n        const originalMockDate = clock[symbol('mockDate')] = clock.mockDate;\n\n        clock.mockDate = function () {\n          const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            const dateTime = arguments.length > 0 ? arguments[0] : new Date();\n            return fakeAsyncZoneSpec.setFakeBaseSystemTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] : arguments);\n          }\n\n          return originalMockDate.apply(this, arguments);\n        }; // for auto go into fakeAsync feature, we need the flag to enable it\n\n\n        if (enableAutoFakeAsyncWhenClockPatched) {\n          ['install', 'uninstall'].forEach(methodName => {\n            const originalClockFn = clock[symbol(methodName)] = clock[methodName];\n\n            clock[methodName] = function () {\n              const FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n\n              if (FakeAsyncTestZoneSpec) {\n                jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                return;\n              }\n\n              return originalClockFn.apply(this, arguments);\n            };\n          });\n        }\n      }\n\n      return clock;\n    };\n  } // monkey patch createSpyObj to make properties enumerable to true\n\n\n  if (!jasmine[Zone.__symbol__('createSpyObj')]) {\n    const originalCreateSpyObj = jasmine.createSpyObj;\n    jasmine[Zone.__symbol__('createSpyObj')] = originalCreateSpyObj;\n\n    jasmine.createSpyObj = function () {\n      const args = Array.prototype.slice.call(arguments);\n      const propertyNames = args.length >= 3 ? args[2] : null;\n      let spyObj;\n\n      if (propertyNames) {\n        const defineProperty = Object.defineProperty;\n\n        Object.defineProperty = function (obj, p, attributes) {\n          return defineProperty.call(this, obj, p, Object.assign(Object.assign({}, attributes), {\n            configurable: true,\n            enumerable: true\n          }));\n        };\n\n        try {\n          spyObj = originalCreateSpyObj.apply(this, args);\n        } finally {\n          Object.defineProperty = defineProperty;\n        }\n      } else {\n        spyObj = originalCreateSpyObj.apply(this, args);\n      }\n\n      return spyObj;\n    };\n  }\n  /**\n   * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n   * synchronous-only zone.\n   */\n\n\n  function wrapDescribeInZone(describeBody) {\n    return function () {\n      return syncZone.run(describeBody, this, arguments);\n    };\n  }\n\n  function runInTestZone(testBody, applyThis, queueRunner, done) {\n    const isClockInstalled = !!jasmine[symbol('clockInstalled')];\n    queueRunner.testProxyZoneSpec;\n    const testProxyZone = queueRunner.testProxyZone;\n\n    if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n      // auto run a fakeAsync\n      const fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n\n      if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n        testBody = fakeAsyncModule.fakeAsync(testBody);\n      }\n    }\n\n    if (done) {\n      return testProxyZone.run(testBody, applyThis, [done]);\n    } else {\n      return testProxyZone.run(testBody, applyThis);\n    }\n  }\n  /**\n   * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n   * execute in a ProxyZone zone.\n   * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n   */\n\n\n  function wrapTestInZone(testBody) {\n    // The `done` callback is only passed through if the function expects at least one argument.\n    // Note we have to make a function with correct number of arguments, otherwise jasmine will\n    // think that all functions are sync or async.\n    return testBody && (testBody.length ? function (done) {\n      return runInTestZone(testBody, this, this.queueRunner, done);\n    } : function () {\n      return runInTestZone(testBody, this, this.queueRunner);\n    });\n  }\n\n  const QueueRunner = jasmine.QueueRunner;\n\n  jasmine.QueueRunner = function (_super) {\n    __extends(ZoneQueueRunner, _super);\n\n    function ZoneQueueRunner(attrs) {\n      if (attrs.onComplete) {\n        attrs.onComplete = (fn => () => {\n          // All functions are done, clear the test zone.\n          this.testProxyZone = null;\n          this.testProxyZoneSpec = null;\n          ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n        })(attrs.onComplete);\n      }\n\n      const nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n\n      const nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n\n      if (nativeSetTimeout) {\n        // should run setTimeout inside jasmine outside of zone\n        attrs.timeout = {\n          setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n          clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout\n        };\n      } // create a userContext to hold the queueRunner itself\n      // so we can access the testProxy in it/xit/beforeEach ...\n\n\n      if (jasmine.UserContext) {\n        if (!attrs.userContext) {\n          attrs.userContext = new jasmine.UserContext();\n        }\n\n        attrs.userContext.queueRunner = this;\n      } else {\n        if (!attrs.userContext) {\n          attrs.userContext = {};\n        }\n\n        attrs.userContext.queueRunner = this;\n      } // patch attrs.onException\n\n\n      const onException = attrs.onException;\n\n      attrs.onException = function (error) {\n        if (error && error.message === 'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n          // jasmine timeout, we can make the error message more\n          // reasonable to tell what tasks are pending\n          const proxyZoneSpec = this && this.testProxyZoneSpec;\n\n          if (proxyZoneSpec) {\n            const pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n\n            try {\n              // try catch here in case error.message is not writable\n              error.message += pendingTasksInfo;\n            } catch (err) {}\n          }\n        }\n\n        if (onException) {\n          onException.call(this, error);\n        }\n      };\n\n      _super.call(this, attrs);\n    }\n\n    ZoneQueueRunner.prototype.execute = function () {\n      let zone = Zone.current;\n      let isChildOfAmbientZone = false;\n\n      while (zone) {\n        if (zone === ambientZone) {\n          isChildOfAmbientZone = true;\n          break;\n        }\n\n        zone = zone.parent;\n      }\n\n      if (!isChildOfAmbientZone) throw new Error('Unexpected Zone: ' + Zone.current.name); // This is the zone which will be used for running individual tests.\n      // It will be a proxy zone, so that the tests function can retroactively install\n      // different zones.\n      // Example:\n      //   - In beforeEach() do childZone = Zone.current.fork(...);\n      //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n      //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n      //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n      //     fakeAsync behavior to the childZone.\n\n      this.testProxyZoneSpec = new ProxyZoneSpec();\n      this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n\n      if (!Zone.currentTask) {\n        // if we are not running in a task then if someone would register a\n        // element.addEventListener and then calling element.click() the\n        // addEventListener callback would think that it is the top most task and would\n        // drain the microtask queue on element.click() which would be incorrect.\n        // For this reason we always force a task when running jasmine tests.\n        Zone.current.scheduleMicroTask('jasmine.execute().forceTask', () => QueueRunner.prototype.execute.call(this));\n      } else {\n        _super.prototype.execute.call(this);\n      }\n    };\n\n    return ZoneQueueRunner;\n  }(QueueRunner);\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nZone.__load_patch('jest', (context, Zone, api) => {\n  if (typeof jest === 'undefined' || jest['__zone_patch__']) {\n    return;\n  }\n\n  jest['__zone_patch__'] = true;\n  const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n  const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n\n  if (!ProxyZoneSpec) {\n    throw new Error('Missing ProxyZoneSpec');\n  }\n\n  const rootZone = Zone.current;\n  const syncZone = rootZone.fork(new SyncTestZoneSpec('jest.describe'));\n  const proxyZoneSpec = new ProxyZoneSpec();\n  const proxyZone = rootZone.fork(proxyZoneSpec);\n\n  function wrapDescribeFactoryInZone(originalJestFn) {\n    return function (...tableArgs) {\n      const originalDescribeFn = originalJestFn.apply(this, tableArgs);\n      return function (...args) {\n        args[1] = wrapDescribeInZone(args[1]);\n        return originalDescribeFn.apply(this, args);\n      };\n    };\n  }\n\n  function wrapTestFactoryInZone(originalJestFn) {\n    return function (...tableArgs) {\n      return function (...args) {\n        args[1] = wrapTestInZone(args[1]);\n        return originalJestFn.apply(this, tableArgs).apply(this, args);\n      };\n    };\n  }\n  /**\n   * Gets a function wrapping the body of a jest `describe` block to execute in a\n   * synchronous-only zone.\n   */\n\n\n  function wrapDescribeInZone(describeBody) {\n    return function (...args) {\n      return syncZone.run(describeBody, this, args);\n    };\n  }\n  /**\n   * Gets a function wrapping the body of a jest `it/beforeEach/afterEach` block to\n   * execute in a ProxyZone zone.\n   * This will run in the `proxyZone`.\n   */\n\n\n  function wrapTestInZone(testBody, isTestFunc = false) {\n    if (typeof testBody !== 'function') {\n      return testBody;\n    }\n\n    const wrappedFunc = function () {\n      if (Zone[api.symbol('useFakeTimersCalled')] === true && testBody && !testBody.isFakeAsync) {\n        // jest.useFakeTimers is called, run into fakeAsyncTest automatically.\n        const fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n\n        if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n          testBody = fakeAsyncModule.fakeAsync(testBody);\n        }\n      }\n\n      proxyZoneSpec.isTestFunc = isTestFunc;\n      return proxyZone.run(testBody, null, arguments);\n    }; // Update the length of wrappedFunc to be the same as the length of the testBody\n    // So jest core can handle whether the test function has `done()` or not correctly\n\n\n    Object.defineProperty(wrappedFunc, 'length', {\n      configurable: true,\n      writable: true,\n      enumerable: false\n    });\n    wrappedFunc.length = testBody.length;\n    return wrappedFunc;\n  }\n\n  ['describe', 'xdescribe', 'fdescribe'].forEach(methodName => {\n    let originalJestFn = context[methodName];\n\n    if (context[Zone.__symbol__(methodName)]) {\n      return;\n    }\n\n    context[Zone.__symbol__(methodName)] = originalJestFn;\n\n    context[methodName] = function (...args) {\n      args[1] = wrapDescribeInZone(args[1]);\n      return originalJestFn.apply(this, args);\n    };\n\n    context[methodName].each = wrapDescribeFactoryInZone(originalJestFn.each);\n  });\n  context.describe.only = context.fdescribe;\n  context.describe.skip = context.xdescribe;\n  ['it', 'xit', 'fit', 'test', 'xtest'].forEach(methodName => {\n    let originalJestFn = context[methodName];\n\n    if (context[Zone.__symbol__(methodName)]) {\n      return;\n    }\n\n    context[Zone.__symbol__(methodName)] = originalJestFn;\n\n    context[methodName] = function (...args) {\n      args[1] = wrapTestInZone(args[1], true);\n      return originalJestFn.apply(this, args);\n    };\n\n    context[methodName].each = wrapTestFactoryInZone(originalJestFn.each);\n    context[methodName].todo = originalJestFn.todo;\n  });\n  context.it.only = context.fit;\n  context.it.skip = context.xit;\n  context.test.only = context.fit;\n  context.test.skip = context.xit;\n  ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(methodName => {\n    let originalJestFn = context[methodName];\n\n    if (context[Zone.__symbol__(methodName)]) {\n      return;\n    }\n\n    context[Zone.__symbol__(methodName)] = originalJestFn;\n\n    context[methodName] = function (...args) {\n      args[0] = wrapTestInZone(args[0]);\n      return originalJestFn.apply(this, args);\n    };\n  });\n\n  Zone.patchJestObject = function patchJestObject(Timer, isModern = false) {\n    // check whether currently the test is inside fakeAsync()\n    function isPatchingFakeTimer() {\n      const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n      return !!fakeAsyncZoneSpec;\n    } // check whether the current function is inside `test/it` or other methods\n    // such as `describe/beforeEach`\n\n\n    function isInTestFunc() {\n      const proxyZoneSpec = Zone.current.get('ProxyZoneSpec');\n      return proxyZoneSpec && proxyZoneSpec.isTestFunc;\n    }\n\n    if (Timer[api.symbol('fakeTimers')]) {\n      return;\n    }\n\n    Timer[api.symbol('fakeTimers')] = true; // patch jest fakeTimer internal method to make sure no console.warn print out\n\n    api.patchMethod(Timer, '_checkFakeTimers', delegate => {\n      return function (self, args) {\n        if (isPatchingFakeTimer()) {\n          return true;\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch useFakeTimers(), set useFakeTimersCalled flag, and make test auto run into fakeAsync\n\n    api.patchMethod(Timer, 'useFakeTimers', delegate => {\n      return function (self, args) {\n        Zone[api.symbol('useFakeTimersCalled')] = true;\n\n        if (isModern || isInTestFunc()) {\n          return delegate.apply(self, args);\n        }\n\n        return self;\n      };\n    }); // patch useRealTimers(), unset useFakeTimers flag\n\n    api.patchMethod(Timer, 'useRealTimers', delegate => {\n      return function (self, args) {\n        Zone[api.symbol('useFakeTimersCalled')] = false;\n\n        if (isModern || isInTestFunc()) {\n          return delegate.apply(self, args);\n        }\n\n        return self;\n      };\n    }); // patch setSystemTime(), call setCurrentRealTime() in the fakeAsyncTest\n\n    api.patchMethod(Timer, 'setSystemTime', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n          fakeAsyncZoneSpec.setFakeBaseSystemTime(args[0]);\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch getSystemTime(), call getCurrentRealTime() in the fakeAsyncTest\n\n    api.patchMethod(Timer, 'getRealSystemTime', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n          return fakeAsyncZoneSpec.getRealSystemTime();\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch runAllTicks(), run all microTasks inside fakeAsync\n\n    api.patchMethod(Timer, 'runAllTicks', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.flushMicrotasks();\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch runAllTimers(), run all macroTasks inside fakeAsync\n\n    api.patchMethod(Timer, 'runAllTimers', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.flush(100, true);\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch advanceTimersByTime(), call tick() in the fakeAsyncTest\n\n    api.patchMethod(Timer, 'advanceTimersByTime', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.tick(args[0]);\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch runOnlyPendingTimers(), call flushOnlyPendingTimers() in the fakeAsyncTest\n\n    api.patchMethod(Timer, 'runOnlyPendingTimers', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.flushOnlyPendingTimers();\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch advanceTimersToNextTimer(), call tickToNext() in the fakeAsyncTest\n\n    api.patchMethod(Timer, 'advanceTimersToNextTimer', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.tickToNext(args[0]);\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch clearAllTimers(), call removeAllTimers() in the fakeAsyncTest\n\n    api.patchMethod(Timer, 'clearAllTimers', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.removeAllTimers();\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch getTimerCount(), call getTimerCount() in the fakeAsyncTest\n\n    api.patchMethod(Timer, 'getTimerCount', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec) {\n          return fakeAsyncZoneSpec.getTimerCount();\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    });\n  };\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nZone.__load_patch('mocha', (global, Zone) => {\n  const Mocha = global.Mocha;\n\n  if (typeof Mocha === 'undefined') {\n    // return if Mocha is not available, because now zone-testing\n    // will load mocha patch with jasmine/jest patch\n    return;\n  }\n\n  if (typeof Zone === 'undefined') {\n    throw new Error('Missing Zone.js');\n  }\n\n  const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n  const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n\n  if (!ProxyZoneSpec) {\n    throw new Error('Missing ProxyZoneSpec');\n  }\n\n  if (Mocha['__zone_patch__']) {\n    throw new Error('\"Mocha\" has already been patched with \"Zone\".');\n  }\n\n  Mocha['__zone_patch__'] = true;\n  const rootZone = Zone.current;\n  const syncZone = rootZone.fork(new SyncTestZoneSpec('Mocha.describe'));\n  let testZone = null;\n  const suiteZone = rootZone.fork(new ProxyZoneSpec());\n  const mochaOriginal = {\n    after: global.after,\n    afterEach: global.afterEach,\n    before: global.before,\n    beforeEach: global.beforeEach,\n    describe: global.describe,\n    it: global.it\n  };\n\n  function modifyArguments(args, syncTest, asyncTest) {\n    for (let i = 0; i < args.length; i++) {\n      let arg = args[i];\n\n      if (typeof arg === 'function') {\n        // The `done` callback is only passed through if the function expects at\n        // least one argument.\n        // Note we have to make a function with correct number of arguments,\n        // otherwise mocha will\n        // think that all functions are sync or async.\n        args[i] = arg.length === 0 ? syncTest(arg) : asyncTest(arg); // Mocha uses toString to view the test body in the result list, make sure we return the\n        // correct function body\n\n        args[i].toString = function () {\n          return arg.toString();\n        };\n      }\n    }\n\n    return args;\n  }\n\n  function wrapDescribeInZone(args) {\n    const syncTest = function (fn) {\n      return function () {\n        return syncZone.run(fn, this, arguments);\n      };\n    };\n\n    return modifyArguments(args, syncTest);\n  }\n\n  function wrapTestInZone(args) {\n    const asyncTest = function (fn) {\n      return function (done) {\n        return testZone.run(fn, this, [done]);\n      };\n    };\n\n    const syncTest = function (fn) {\n      return function () {\n        return testZone.run(fn, this);\n      };\n    };\n\n    return modifyArguments(args, syncTest, asyncTest);\n  }\n\n  function wrapSuiteInZone(args) {\n    const asyncTest = function (fn) {\n      return function (done) {\n        return suiteZone.run(fn, this, [done]);\n      };\n    };\n\n    const syncTest = function (fn) {\n      return function () {\n        return suiteZone.run(fn, this);\n      };\n    };\n\n    return modifyArguments(args, syncTest, asyncTest);\n  }\n\n  global.describe = global.suite = function () {\n    return mochaOriginal.describe.apply(this, wrapDescribeInZone(arguments));\n  };\n\n  global.xdescribe = global.suite.skip = function () {\n    return mochaOriginal.describe.skip.apply(this, wrapDescribeInZone(arguments));\n  };\n\n  global.describe.only = global.suite.only = function () {\n    return mochaOriginal.describe.only.apply(this, wrapDescribeInZone(arguments));\n  };\n\n  global.it = global.specify = global.test = function () {\n    return mochaOriginal.it.apply(this, wrapTestInZone(arguments));\n  };\n\n  global.xit = global.xspecify = function () {\n    return mochaOriginal.it.skip.apply(this, wrapTestInZone(arguments));\n  };\n\n  global.it.only = global.test.only = function () {\n    return mochaOriginal.it.only.apply(this, wrapTestInZone(arguments));\n  };\n\n  global.after = global.suiteTeardown = function () {\n    return mochaOriginal.after.apply(this, wrapSuiteInZone(arguments));\n  };\n\n  global.afterEach = global.teardown = function () {\n    return mochaOriginal.afterEach.apply(this, wrapTestInZone(arguments));\n  };\n\n  global.before = global.suiteSetup = function () {\n    return mochaOriginal.before.apply(this, wrapSuiteInZone(arguments));\n  };\n\n  global.beforeEach = global.setup = function () {\n    return mochaOriginal.beforeEach.apply(this, wrapTestInZone(arguments));\n  };\n\n  ((originalRunTest, originalRun) => {\n    Mocha.Runner.prototype.runTest = function (fn) {\n      Zone.current.scheduleMicroTask('mocha.forceTask', () => {\n        originalRunTest.call(this, fn);\n      });\n    };\n\n    Mocha.Runner.prototype.run = function (fn) {\n      this.on('test', e => {\n        testZone = rootZone.fork(new ProxyZoneSpec());\n      });\n      this.on('fail', (test, err) => {\n        const proxyZoneSpec = testZone && testZone.get('ProxyZoneSpec');\n\n        if (proxyZoneSpec && err) {\n          try {\n            // try catch here in case err.message is not writable\n            err.message += proxyZoneSpec.getAndClearPendingTasksInfo();\n          } catch (error) {}\n        }\n      });\n      return originalRun.call(this, fn);\n    };\n  })(Mocha.Runner.prototype.runTest, Mocha.Runner.prototype.run);\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n(function (_global) {\n  class AsyncTestZoneSpec {\n    constructor(finishCallback, failCallback, namePrefix) {\n      this.finishCallback = finishCallback;\n      this.failCallback = failCallback;\n      this._pendingMicroTasks = false;\n      this._pendingMacroTasks = false;\n      this._alreadyErrored = false;\n      this._isSync = false;\n      this.entryFunction = null;\n      this.runZone = Zone.current;\n      this.unresolvedChainedPromiseCount = 0;\n      this.supportWaitUnresolvedChainedPromise = false;\n      this.name = 'asyncTestZone for ' + namePrefix;\n      this.properties = {\n        'AsyncTestZoneSpec': this\n      };\n      this.supportWaitUnresolvedChainedPromise = _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n    }\n\n    isUnresolvedChainedPromisePending() {\n      return this.unresolvedChainedPromiseCount > 0;\n    }\n\n    _finishCallbackIfDone() {\n      if (!(this._pendingMicroTasks || this._pendingMacroTasks || this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending())) {\n        // We do this because we would like to catch unhandled rejected promises.\n        this.runZone.run(() => {\n          setTimeout(() => {\n            if (!this._alreadyErrored && !(this._pendingMicroTasks || this._pendingMacroTasks)) {\n              this.finishCallback();\n            }\n          }, 0);\n        });\n      }\n    }\n\n    patchPromiseForTest() {\n      if (!this.supportWaitUnresolvedChainedPromise) {\n        return;\n      }\n\n      const patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n\n      if (patchPromiseForTest) {\n        patchPromiseForTest();\n      }\n    }\n\n    unPatchPromiseForTest() {\n      if (!this.supportWaitUnresolvedChainedPromise) {\n        return;\n      }\n\n      const unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n\n      if (unPatchPromiseForTest) {\n        unPatchPromiseForTest();\n      }\n    }\n\n    onScheduleTask(delegate, current, target, task) {\n      if (task.type !== 'eventTask') {\n        this._isSync = false;\n      }\n\n      if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n        // check whether the promise is a chained promise\n        if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n          // chained promise is being scheduled\n          this.unresolvedChainedPromiseCount--;\n        }\n      }\n\n      return delegate.scheduleTask(target, task);\n    }\n\n    onInvokeTask(delegate, current, target, task, applyThis, applyArgs) {\n      if (task.type !== 'eventTask') {\n        this._isSync = false;\n      }\n\n      return delegate.invokeTask(target, task, applyThis, applyArgs);\n    }\n\n    onCancelTask(delegate, current, target, task) {\n      if (task.type !== 'eventTask') {\n        this._isSync = false;\n      }\n\n      return delegate.cancelTask(target, task);\n    } // Note - we need to use onInvoke at the moment to call finish when a test is\n    // fully synchronous. TODO(juliemr): remove this when the logic for\n    // onHasTask changes and it calls whenever the task queues are dirty.\n    // updated by(JiaLiPassion), only call finish callback when no task\n    // was scheduled/invoked/canceled.\n\n\n    onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n      if (!this.entryFunction) {\n        this.entryFunction = delegate;\n      }\n\n      try {\n        this._isSync = true;\n        return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n      } finally {\n        parentZoneDelegate._taskCounts; // We need to check the delegate is the same as entryFunction or not.\n        // Consider the following case.\n        //\n        // asyncTestZone.run(() => { // Here the delegate will be the entryFunction\n        //   Zone.current.run(() => { // Here the delegate will not be the entryFunction\n        //   });\n        // });\n        //\n        // We only want to check whether there are async tasks scheduled\n        // for the entry function.\n\n        if (this._isSync && this.entryFunction === delegate) {\n          this._finishCallbackIfDone();\n        }\n      }\n    }\n\n    onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n      // Let the parent try to handle the error.\n      const result = parentZoneDelegate.handleError(targetZone, error);\n\n      if (result) {\n        this.failCallback(error);\n        this._alreadyErrored = true;\n      }\n\n      return false;\n    }\n\n    onHasTask(delegate, current, target, hasTaskState) {\n      delegate.hasTask(target, hasTaskState); // We should only trigger finishCallback when the target zone is the AsyncTestZone\n      // Consider the following cases.\n      //\n      // const childZone = asyncTestZone.fork({\n      //   name: 'child',\n      //   onHasTask: ...\n      // });\n      //\n      // So we have nested zones declared the onHasTask hook, in this case,\n      // the onHasTask will be triggered twice, and cause the finishCallbackIfDone()\n      // is also be invoked twice. So we need to only trigger the finishCallbackIfDone()\n      // when the current zone is the same as the target zone.\n\n      if (current !== target) {\n        return;\n      }\n\n      if (hasTaskState.change == 'microTask') {\n        this._pendingMicroTasks = hasTaskState.microTask;\n\n        this._finishCallbackIfDone();\n      } else if (hasTaskState.change == 'macroTask') {\n        this._pendingMacroTasks = hasTaskState.macroTask;\n\n        this._finishCallbackIfDone();\n      }\n    }\n\n  }\n\n  AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__('parentUnresolved'); // Export the class so that new instances can be created with proper\n  // constructor params.\n\n  Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n})(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n\nZone.__load_patch('asynctest', (global, Zone, api) => {\n  /**\n   * Wraps a test function in an asynchronous test zone. The test will automatically\n   * complete when all asynchronous calls within this zone are done.\n   */\n  Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n    // If we're running using the Jasmine test framework, adapt to call the 'done'\n    // function when asynchronous activity is finished.\n    if (global.jasmine) {\n      // Not using an arrow function to preserve context passed from call site\n      return function (done) {\n        if (!done) {\n          // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n          // fake it here and assume sync.\n          done = function () {};\n\n          done.fail = function (e) {\n            throw e;\n          };\n        }\n\n        runInTestZone(fn, this, done, err => {\n          if (typeof err === 'string') {\n            return done.fail(new Error(err));\n          } else {\n            done.fail(err);\n          }\n        });\n      };\n    } // Otherwise, return a promise which will resolve when asynchronous activity\n    // is finished. This will be correctly consumed by the Mocha framework with\n    // it('...', async(myFn)); or can be used in a custom framework.\n    // Not using an arrow function to preserve context passed from call site\n\n\n    return function () {\n      return new Promise((finishCallback, failCallback) => {\n        runInTestZone(fn, this, finishCallback, failCallback);\n      });\n    };\n  };\n\n  function runInTestZone(fn, context, finishCallback, failCallback) {\n    const currentZone = Zone.current;\n    const AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n\n    if (AsyncTestZoneSpec === undefined) {\n      throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/plugins/async-test');\n    }\n\n    const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n\n    if (!ProxyZoneSpec) {\n      throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/plugins/proxy');\n    }\n\n    const proxyZoneSpec = ProxyZoneSpec.get();\n    ProxyZoneSpec.assertPresent(); // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n    // If we do it in ProxyZone then we will get to infinite recursion.\n\n    const proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n    const previousDelegate = proxyZoneSpec.getDelegate();\n    proxyZone.parent.run(() => {\n      const testZoneSpec = new AsyncTestZoneSpec(() => {\n        // Need to restore the original zone.\n        if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n          // Only reset the zone spec if it's\n          // sill this one. Otherwise, assume\n          // it's OK.\n          proxyZoneSpec.setDelegate(previousDelegate);\n        }\n\n        testZoneSpec.unPatchPromiseForTest();\n        currentZone.run(() => {\n          finishCallback();\n        });\n      }, error => {\n        // Need to restore the original zone.\n        if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n          // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n          proxyZoneSpec.setDelegate(previousDelegate);\n        }\n\n        testZoneSpec.unPatchPromiseForTest();\n        currentZone.run(() => {\n          failCallback(error);\n        });\n      }, 'test');\n      proxyZoneSpec.setDelegate(testZoneSpec);\n      testZoneSpec.patchPromiseForTest();\n    });\n    return Zone.current.runGuarded(fn, context);\n  }\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n(function (global) {\n  const OriginalDate = global.Date; // Since when we compile this file to `es2015`, and if we define\n  // this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n  // there will be an error which is `Cannot assign to read only property 'prototype'`\n  // so we need to use function implementation here.\n\n  function FakeDate() {\n    if (arguments.length === 0) {\n      const d = new OriginalDate();\n      d.setTime(FakeDate.now());\n      return d;\n    } else {\n      const args = Array.prototype.slice.call(arguments);\n      return new OriginalDate(...args);\n    }\n  }\n\n  FakeDate.now = function () {\n    const fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n    if (fakeAsyncTestZoneSpec) {\n      return fakeAsyncTestZoneSpec.getFakeSystemTime();\n    }\n\n    return OriginalDate.now.apply(this, arguments);\n  };\n\n  FakeDate.UTC = OriginalDate.UTC;\n  FakeDate.parse = OriginalDate.parse; // keep a reference for zone patched timer function\n\n  const timers = {\n    setTimeout: global.setTimeout,\n    setInterval: global.setInterval,\n    clearTimeout: global.clearTimeout,\n    clearInterval: global.clearInterval\n  };\n\n  class Scheduler {\n    constructor() {\n      // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n      this._schedulerQueue = []; // Current simulated time in millis.\n\n      this._currentTickTime = 0; // Current fake system base time in millis.\n\n      this._currentFakeBaseSystemTime = OriginalDate.now(); // track requeuePeriodicTimer\n\n      this._currentTickRequeuePeriodicEntries = [];\n    }\n\n    getCurrentTickTime() {\n      return this._currentTickTime;\n    }\n\n    getFakeSystemTime() {\n      return this._currentFakeBaseSystemTime + this._currentTickTime;\n    }\n\n    setFakeBaseSystemTime(fakeBaseSystemTime) {\n      this._currentFakeBaseSystemTime = fakeBaseSystemTime;\n    }\n\n    getRealSystemTime() {\n      return OriginalDate.now();\n    }\n\n    scheduleFunction(cb, delay, options) {\n      options = Object.assign({\n        args: [],\n        isPeriodic: false,\n        isRequestAnimationFrame: false,\n        id: -1,\n        isRequeuePeriodic: false\n      }, options);\n      let currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n      let endTime = this._currentTickTime + delay; // Insert so that scheduler queue remains sorted by end time.\n\n      let newEntry = {\n        endTime: endTime,\n        id: currentId,\n        func: cb,\n        args: options.args,\n        delay: delay,\n        isPeriodic: options.isPeriodic,\n        isRequestAnimationFrame: options.isRequestAnimationFrame\n      };\n\n      if (options.isRequeuePeriodic) {\n        this._currentTickRequeuePeriodicEntries.push(newEntry);\n      }\n\n      let i = 0;\n\n      for (; i < this._schedulerQueue.length; i++) {\n        let currentEntry = this._schedulerQueue[i];\n\n        if (newEntry.endTime < currentEntry.endTime) {\n          break;\n        }\n      }\n\n      this._schedulerQueue.splice(i, 0, newEntry);\n\n      return currentId;\n    }\n\n    removeScheduledFunctionWithId(id) {\n      for (let i = 0; i < this._schedulerQueue.length; i++) {\n        if (this._schedulerQueue[i].id == id) {\n          this._schedulerQueue.splice(i, 1);\n\n          break;\n        }\n      }\n    }\n\n    removeAll() {\n      this._schedulerQueue = [];\n    }\n\n    getTimerCount() {\n      return this._schedulerQueue.length;\n    }\n\n    tickToNext(step = 1, doTick, tickOptions) {\n      if (this._schedulerQueue.length < step) {\n        return;\n      } // Find the last task currently queued in the scheduler queue and tick\n      // till that time.\n\n\n      const startTime = this._currentTickTime;\n      const targetTask = this._schedulerQueue[step - 1];\n      this.tick(targetTask.endTime - startTime, doTick, tickOptions);\n    }\n\n    tick(millis = 0, doTick, tickOptions) {\n      let finalTime = this._currentTickTime + millis;\n      let lastCurrentTime = 0;\n      tickOptions = Object.assign({\n        processNewMacroTasksSynchronously: true\n      }, tickOptions); // we need to copy the schedulerQueue so nested timeout\n      // will not be wrongly called in the current tick\n      // https://github.com/angular/angular/issues/33799\n\n      const schedulerQueue = tickOptions.processNewMacroTasksSynchronously ? this._schedulerQueue : this._schedulerQueue.slice();\n\n      if (schedulerQueue.length === 0 && doTick) {\n        doTick(millis);\n        return;\n      }\n\n      while (schedulerQueue.length > 0) {\n        // clear requeueEntries before each loop\n        this._currentTickRequeuePeriodicEntries = [];\n        let current = schedulerQueue[0];\n\n        if (finalTime < current.endTime) {\n          // Done processing the queue since it's sorted by endTime.\n          break;\n        } else {\n          // Time to run scheduled function. Remove it from the head of queue.\n          let current = schedulerQueue.shift();\n\n          if (!tickOptions.processNewMacroTasksSynchronously) {\n            const idx = this._schedulerQueue.indexOf(current);\n\n            if (idx >= 0) {\n              this._schedulerQueue.splice(idx, 1);\n            }\n          }\n\n          lastCurrentTime = this._currentTickTime;\n          this._currentTickTime = current.endTime;\n\n          if (doTick) {\n            doTick(this._currentTickTime - lastCurrentTime);\n          }\n\n          let retval = current.func.apply(global, current.isRequestAnimationFrame ? [this._currentTickTime] : current.args);\n\n          if (!retval) {\n            // Uncaught exception in the current scheduled function. Stop processing the queue.\n            break;\n          } // check is there any requeue periodic entry is added in\n          // current loop, if there is, we need to add to current loop\n\n\n          if (!tickOptions.processNewMacroTasksSynchronously) {\n            this._currentTickRequeuePeriodicEntries.forEach(newEntry => {\n              let i = 0;\n\n              for (; i < schedulerQueue.length; i++) {\n                const currentEntry = schedulerQueue[i];\n\n                if (newEntry.endTime < currentEntry.endTime) {\n                  break;\n                }\n              }\n\n              schedulerQueue.splice(i, 0, newEntry);\n            });\n          }\n        }\n      }\n\n      lastCurrentTime = this._currentTickTime;\n      this._currentTickTime = finalTime;\n\n      if (doTick) {\n        doTick(this._currentTickTime - lastCurrentTime);\n      }\n    }\n\n    flushOnlyPendingTimers(doTick) {\n      if (this._schedulerQueue.length === 0) {\n        return 0;\n      } // Find the last task currently queued in the scheduler queue and tick\n      // till that time.\n\n\n      const startTime = this._currentTickTime;\n      const lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n      this.tick(lastTask.endTime - startTime, doTick, {\n        processNewMacroTasksSynchronously: false\n      });\n      return this._currentTickTime - startTime;\n    }\n\n    flush(limit = 20, flushPeriodic = false, doTick) {\n      if (flushPeriodic) {\n        return this.flushPeriodic(doTick);\n      } else {\n        return this.flushNonPeriodic(limit, doTick);\n      }\n    }\n\n    flushPeriodic(doTick) {\n      if (this._schedulerQueue.length === 0) {\n        return 0;\n      } // Find the last task currently queued in the scheduler queue and tick\n      // till that time.\n\n\n      const startTime = this._currentTickTime;\n      const lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n      this.tick(lastTask.endTime - startTime, doTick);\n      return this._currentTickTime - startTime;\n    }\n\n    flushNonPeriodic(limit, doTick) {\n      const startTime = this._currentTickTime;\n      let lastCurrentTime = 0;\n      let count = 0;\n\n      while (this._schedulerQueue.length > 0) {\n        count++;\n\n        if (count > limit) {\n          throw new Error('flush failed after reaching the limit of ' + limit + ' tasks. Does your code use a polling timeout?');\n        } // flush only non-periodic timers.\n        // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n\n\n        if (this._schedulerQueue.filter(task => !task.isPeriodic && !task.isRequestAnimationFrame).length === 0) {\n          break;\n        }\n\n        const current = this._schedulerQueue.shift();\n\n        lastCurrentTime = this._currentTickTime;\n        this._currentTickTime = current.endTime;\n\n        if (doTick) {\n          // Update any secondary schedulers like Jasmine mock Date.\n          doTick(this._currentTickTime - lastCurrentTime);\n        }\n\n        const retval = current.func.apply(global, current.args);\n\n        if (!retval) {\n          // Uncaught exception in the current scheduled function. Stop processing the queue.\n          break;\n        }\n      }\n\n      return this._currentTickTime - startTime;\n    }\n\n  } // Next scheduler id.\n\n\n  Scheduler.nextId = 1;\n\n  class FakeAsyncTestZoneSpec {\n    constructor(namePrefix, trackPendingRequestAnimationFrame = false, macroTaskOptions) {\n      this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n      this.macroTaskOptions = macroTaskOptions;\n      this._scheduler = new Scheduler();\n      this._microtasks = [];\n      this._lastError = null;\n      this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n      this.pendingPeriodicTimers = [];\n      this.pendingTimers = [];\n      this.patchDateLocked = false;\n      this.properties = {\n        'FakeAsyncTestZoneSpec': this\n      };\n      this.name = 'fakeAsyncTestZone for ' + namePrefix; // in case user can't access the construction of FakeAsyncTestSpec\n      // user can also define macroTaskOptions by define a global variable.\n\n      if (!this.macroTaskOptions) {\n        this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n      }\n    }\n\n    static assertInZone() {\n      if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n        throw new Error('The code should be running in the fakeAsync zone to call this function');\n      }\n    }\n\n    _fnAndFlush(fn, completers) {\n      return (...args) => {\n        fn.apply(global, args);\n\n        if (this._lastError === null) {\n          // Success\n          if (completers.onSuccess != null) {\n            completers.onSuccess.apply(global);\n          } // Flush microtasks only on success.\n\n\n          this.flushMicrotasks();\n        } else {\n          // Failure\n          if (completers.onError != null) {\n            completers.onError.apply(global);\n          }\n        } // Return true if there were no errors, false otherwise.\n\n\n        return this._lastError === null;\n      };\n    }\n\n    static _removeTimer(timers, id) {\n      let index = timers.indexOf(id);\n\n      if (index > -1) {\n        timers.splice(index, 1);\n      }\n    }\n\n    _dequeueTimer(id) {\n      return () => {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n      };\n    }\n\n    _requeuePeriodicTimer(fn, interval, args, id) {\n      return () => {\n        // Requeue the timer callback if it's not been canceled.\n        if (this.pendingPeriodicTimers.indexOf(id) !== -1) {\n          this._scheduler.scheduleFunction(fn, interval, {\n            args,\n            isPeriodic: true,\n            id,\n            isRequeuePeriodic: true\n          });\n        }\n      };\n    }\n\n    _dequeuePeriodicTimer(id) {\n      return () => {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n      };\n    }\n\n    _setTimeout(fn, delay, args, isTimer = true) {\n      let removeTimerFn = this._dequeueTimer(Scheduler.nextId); // Queue the callback and dequeue the timer on success and error.\n\n\n      let cb = this._fnAndFlush(fn, {\n        onSuccess: removeTimerFn,\n        onError: removeTimerFn\n      });\n\n      let id = this._scheduler.scheduleFunction(cb, delay, {\n        args,\n        isRequestAnimationFrame: !isTimer\n      });\n\n      if (isTimer) {\n        this.pendingTimers.push(id);\n      }\n\n      return id;\n    }\n\n    _clearTimeout(id) {\n      FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n\n      this._scheduler.removeScheduledFunctionWithId(id);\n    }\n\n    _setInterval(fn, interval, args) {\n      let id = Scheduler.nextId;\n      let completers = {\n        onSuccess: null,\n        onError: this._dequeuePeriodicTimer(id)\n      };\n\n      let cb = this._fnAndFlush(fn, completers); // Use the callback created above to requeue on success.\n\n\n      completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id); // Queue the callback and dequeue the periodic timer only on error.\n\n      this._scheduler.scheduleFunction(cb, interval, {\n        args,\n        isPeriodic: true\n      });\n\n      this.pendingPeriodicTimers.push(id);\n      return id;\n    }\n\n    _clearInterval(id) {\n      FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n\n      this._scheduler.removeScheduledFunctionWithId(id);\n    }\n\n    _resetLastErrorAndThrow() {\n      let error = this._lastError || this._uncaughtPromiseErrors[0];\n      this._uncaughtPromiseErrors.length = 0;\n      this._lastError = null;\n      throw error;\n    }\n\n    getCurrentTickTime() {\n      return this._scheduler.getCurrentTickTime();\n    }\n\n    getFakeSystemTime() {\n      return this._scheduler.getFakeSystemTime();\n    }\n\n    setFakeBaseSystemTime(realTime) {\n      this._scheduler.setFakeBaseSystemTime(realTime);\n    }\n\n    getRealSystemTime() {\n      return this._scheduler.getRealSystemTime();\n    }\n\n    static patchDate() {\n      if (!!global[Zone.__symbol__('disableDatePatching')]) {\n        // we don't want to patch global Date\n        // because in some case, global Date\n        // is already being patched, we need to provide\n        // an option to let user still use their\n        // own version of Date.\n        return;\n      }\n\n      if (global['Date'] === FakeDate) {\n        // already patched\n        return;\n      }\n\n      global['Date'] = FakeDate;\n      FakeDate.prototype = OriginalDate.prototype; // try check and reset timers\n      // because jasmine.clock().install() may\n      // have replaced the global timer\n\n      FakeAsyncTestZoneSpec.checkTimerPatch();\n    }\n\n    static resetDate() {\n      if (global['Date'] === FakeDate) {\n        global['Date'] = OriginalDate;\n      }\n    }\n\n    static checkTimerPatch() {\n      if (global.setTimeout !== timers.setTimeout) {\n        global.setTimeout = timers.setTimeout;\n        global.clearTimeout = timers.clearTimeout;\n      }\n\n      if (global.setInterval !== timers.setInterval) {\n        global.setInterval = timers.setInterval;\n        global.clearInterval = timers.clearInterval;\n      }\n    }\n\n    lockDatePatch() {\n      this.patchDateLocked = true;\n      FakeAsyncTestZoneSpec.patchDate();\n    }\n\n    unlockDatePatch() {\n      this.patchDateLocked = false;\n      FakeAsyncTestZoneSpec.resetDate();\n    }\n\n    tickToNext(steps = 1, doTick, tickOptions = {\n      processNewMacroTasksSynchronously: true\n    }) {\n      if (steps <= 0) {\n        return;\n      }\n\n      FakeAsyncTestZoneSpec.assertInZone();\n      this.flushMicrotasks();\n\n      this._scheduler.tickToNext(steps, doTick, tickOptions);\n\n      if (this._lastError !== null) {\n        this._resetLastErrorAndThrow();\n      }\n    }\n\n    tick(millis = 0, doTick, tickOptions = {\n      processNewMacroTasksSynchronously: true\n    }) {\n      FakeAsyncTestZoneSpec.assertInZone();\n      this.flushMicrotasks();\n\n      this._scheduler.tick(millis, doTick, tickOptions);\n\n      if (this._lastError !== null) {\n        this._resetLastErrorAndThrow();\n      }\n    }\n\n    flushMicrotasks() {\n      FakeAsyncTestZoneSpec.assertInZone();\n\n      const flushErrors = () => {\n        if (this._lastError !== null || this._uncaughtPromiseErrors.length) {\n          // If there is an error stop processing the microtask queue and rethrow the error.\n          this._resetLastErrorAndThrow();\n        }\n      };\n\n      while (this._microtasks.length > 0) {\n        let microtask = this._microtasks.shift();\n\n        microtask.func.apply(microtask.target, microtask.args);\n      }\n\n      flushErrors();\n    }\n\n    flush(limit, flushPeriodic, doTick) {\n      FakeAsyncTestZoneSpec.assertInZone();\n      this.flushMicrotasks();\n\n      const elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n\n      if (this._lastError !== null) {\n        this._resetLastErrorAndThrow();\n      }\n\n      return elapsed;\n    }\n\n    flushOnlyPendingTimers(doTick) {\n      FakeAsyncTestZoneSpec.assertInZone();\n      this.flushMicrotasks();\n\n      const elapsed = this._scheduler.flushOnlyPendingTimers(doTick);\n\n      if (this._lastError !== null) {\n        this._resetLastErrorAndThrow();\n      }\n\n      return elapsed;\n    }\n\n    removeAllTimers() {\n      FakeAsyncTestZoneSpec.assertInZone();\n\n      this._scheduler.removeAll();\n\n      this.pendingPeriodicTimers = [];\n      this.pendingTimers = [];\n    }\n\n    getTimerCount() {\n      return this._scheduler.getTimerCount() + this._microtasks.length;\n    }\n\n    onScheduleTask(delegate, current, target, task) {\n      switch (task.type) {\n        case 'microTask':\n          let args = task.data && task.data.args; // should pass additional arguments to callback if have any\n          // currently we know process.nextTick will have such additional\n          // arguments\n\n          let additionalArgs;\n\n          if (args) {\n            let callbackIndex = task.data.cbIdx;\n\n            if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n              additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n            }\n          }\n\n          this._microtasks.push({\n            func: task.invoke,\n            args: additionalArgs,\n            target: task.data && task.data.target\n          });\n\n          break;\n\n        case 'macroTask':\n          switch (task.source) {\n            case 'setTimeout':\n              task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n              break;\n\n            case 'setImmediate':\n              task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n              break;\n\n            case 'setInterval':\n              task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n              break;\n\n            case 'XMLHttpRequest.send':\n              throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' + task.data['url']);\n\n            case 'requestAnimationFrame':\n            case 'webkitRequestAnimationFrame':\n            case 'mozRequestAnimationFrame':\n              // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n              // (60 frames per second)\n              task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n              break;\n\n            default:\n              // user can define which macroTask they want to support by passing\n              // macroTaskOptions\n              const macroTaskOption = this.findMacroTaskOption(task);\n\n              if (macroTaskOption) {\n                const args = task.data && task.data['args'];\n                const delay = args && args.length > 1 ? args[1] : 0;\n                let callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args;\n\n                if (!!macroTaskOption.isPeriodic) {\n                  // periodic macroTask, use setInterval to simulate\n                  task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                  task.data.isPeriodic = true;\n                } else {\n                  // not periodic, use setTimeout to simulate\n                  task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                }\n\n                break;\n              }\n\n              throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n          }\n\n          break;\n\n        case 'eventTask':\n          task = delegate.scheduleTask(target, task);\n          break;\n      }\n\n      return task;\n    }\n\n    onCancelTask(delegate, current, target, task) {\n      switch (task.source) {\n        case 'setTimeout':\n        case 'requestAnimationFrame':\n        case 'webkitRequestAnimationFrame':\n        case 'mozRequestAnimationFrame':\n          return this._clearTimeout(task.data['handleId']);\n\n        case 'setInterval':\n          return this._clearInterval(task.data['handleId']);\n\n        default:\n          // user can define which macroTask they want to support by passing\n          // macroTaskOptions\n          const macroTaskOption = this.findMacroTaskOption(task);\n\n          if (macroTaskOption) {\n            const handleId = task.data['handleId'];\n            return macroTaskOption.isPeriodic ? this._clearInterval(handleId) : this._clearTimeout(handleId);\n          }\n\n          return delegate.cancelTask(target, task);\n      }\n    }\n\n    onInvoke(delegate, current, target, callback, applyThis, applyArgs, source) {\n      try {\n        FakeAsyncTestZoneSpec.patchDate();\n        return delegate.invoke(target, callback, applyThis, applyArgs, source);\n      } finally {\n        if (!this.patchDateLocked) {\n          FakeAsyncTestZoneSpec.resetDate();\n        }\n      }\n    }\n\n    findMacroTaskOption(task) {\n      if (!this.macroTaskOptions) {\n        return null;\n      }\n\n      for (let i = 0; i < this.macroTaskOptions.length; i++) {\n        const macroTaskOption = this.macroTaskOptions[i];\n\n        if (macroTaskOption.source === task.source) {\n          return macroTaskOption;\n        }\n      }\n\n      return null;\n    }\n\n    onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n      this._lastError = error;\n      return false; // Don't propagate error to parent zone.\n    }\n\n  } // Export the class so that new instances can be created with proper\n  // constructor params.\n\n\n  Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n})(typeof window === 'object' && window || typeof self === 'object' && self || global);\n\nZone.__load_patch('fakeasync', (global, Zone, api) => {\n  const FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n\n  function getProxyZoneSpec() {\n    return Zone && Zone['ProxyZoneSpec'];\n  }\n\n  let _fakeAsyncTestZoneSpec = null;\n  /**\n   * Clears out the shared fake async zone for a test.\n   * To be called in a global `beforeEach`.\n   *\n   * @experimental\n   */\n\n  function resetFakeAsyncZone() {\n    if (_fakeAsyncTestZoneSpec) {\n      _fakeAsyncTestZoneSpec.unlockDatePatch();\n    }\n\n    _fakeAsyncTestZoneSpec = null; // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n\n    getProxyZoneSpec() && getProxyZoneSpec().assertPresent().resetDelegate();\n  }\n  /**\n   * Wraps a function to be executed in the fakeAsync zone:\n   * - microtasks are manually executed by calling `flushMicrotasks()`,\n   * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n   *\n   * If there are any pending timers at the end of the function, an exception will be thrown.\n   *\n   * Can be used to wrap inject() calls.\n   *\n   * ## Example\n   *\n   * {@example core/testing/ts/fake_async.ts region='basic'}\n   *\n   * @param fn\n   * @returns The function wrapped to be executed in the fakeAsync zone\n   *\n   * @experimental\n   */\n\n\n  function fakeAsync(fn) {\n    // Not using an arrow function to preserve context passed from call site\n    const fakeAsyncFn = function (...args) {\n      const ProxyZoneSpec = getProxyZoneSpec();\n\n      if (!ProxyZoneSpec) {\n        throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/plugins/proxy');\n      }\n\n      const proxyZoneSpec = ProxyZoneSpec.assertPresent();\n\n      if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n        throw new Error('fakeAsync() calls can not be nested');\n      }\n\n      try {\n        // in case jasmine.clock init a fakeAsyncTestZoneSpec\n        if (!_fakeAsyncTestZoneSpec) {\n          if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n            throw new Error('fakeAsync() calls can not be nested');\n          }\n\n          _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n        }\n\n        let res;\n        const lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n        proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n\n        _fakeAsyncTestZoneSpec.lockDatePatch();\n\n        try {\n          res = fn.apply(this, args);\n          flushMicrotasks();\n        } finally {\n          proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n        }\n\n        if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n          throw new Error(`${_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length} ` + `periodic timer(s) still in the queue.`);\n        }\n\n        if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n          throw new Error(`${_fakeAsyncTestZoneSpec.pendingTimers.length} timer(s) still in the queue.`);\n        }\n\n        return res;\n      } finally {\n        resetFakeAsyncZone();\n      }\n    };\n\n    fakeAsyncFn.isFakeAsync = true;\n    return fakeAsyncFn;\n  }\n\n  function _getFakeAsyncZoneSpec() {\n    if (_fakeAsyncTestZoneSpec == null) {\n      _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n      if (_fakeAsyncTestZoneSpec == null) {\n        throw new Error('The code should be running in the fakeAsync zone to call this function');\n      }\n    }\n\n    return _fakeAsyncTestZoneSpec;\n  }\n  /**\n   * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n   *\n   * The microtasks queue is drained at the very start of this function and after any timer callback\n   * has been executed.\n   *\n   * ## Example\n   *\n   * {@example core/testing/ts/fake_async.ts region='basic'}\n   *\n   * @experimental\n   */\n\n\n  function tick(millis = 0, ignoreNestedTimeout = false) {\n    _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n  }\n  /**\n   * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n   * draining the macrotask queue until it is empty. The returned value is the milliseconds\n   * of time that would have been elapsed.\n   *\n   * @param maxTurns\n   * @returns The simulated time elapsed, in millis.\n   *\n   * @experimental\n   */\n\n\n  function flush(maxTurns) {\n    return _getFakeAsyncZoneSpec().flush(maxTurns);\n  }\n  /**\n   * Discard all remaining periodic tasks.\n   *\n   * @experimental\n   */\n\n\n  function discardPeriodicTasks() {\n    const zoneSpec = _getFakeAsyncZoneSpec();\n\n    zoneSpec.pendingPeriodicTimers;\n    zoneSpec.pendingPeriodicTimers.length = 0;\n  }\n  /**\n   * Flush any pending microtasks.\n   *\n   * @experimental\n   */\n\n\n  function flushMicrotasks() {\n    _getFakeAsyncZoneSpec().flushMicrotasks();\n  }\n\n  Zone[api.symbol('fakeAsyncTest')] = {\n    resetFakeAsyncZone,\n    flushMicrotasks,\n    discardPeriodicTasks,\n    tick,\n    flush,\n    fakeAsync\n  };\n}, true);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Promise for async/fakeAsync zoneSpec test\n * can support async operation which not supported by zone.js\n * such as\n * it ('test jsonp in AsyncZone', async() => {\n *   new Promise(res => {\n *     jsonp(url, (data) => {\n *       // success callback\n *       res(data);\n *     });\n *   }).then((jsonpResult) => {\n *     // get jsonp result.\n *\n *     // user will expect AsyncZoneSpec wait for\n *     // then, but because jsonp is not zone aware\n *     // AsyncZone will finish before then is called.\n *   });\n * });\n */\n\n\nZone.__load_patch('promisefortest', (global, Zone, api) => {\n  const symbolState = api.symbol('state');\n  const UNRESOLVED = null;\n  const symbolParentUnresolved = api.symbol('parentUnresolved'); // patch Promise.prototype.then to keep an internal\n  // number for tracking unresolved chained promise\n  // we will decrease this number when the parent promise\n  // being resolved/rejected and chained promise was\n  // scheduled as a microTask.\n  // so we can know such kind of chained promise still\n  // not resolved in AsyncTestZone\n\n  Promise[api.symbol('patchPromiseForTest')] = function patchPromiseForTest() {\n    let oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n\n    if (oriThen) {\n      return;\n    }\n\n    oriThen = Promise[Zone.__symbol__('ZonePromiseThen')] = Promise.prototype.then;\n\n    Promise.prototype.then = function () {\n      const chained = oriThen.apply(this, arguments);\n\n      if (this[symbolState] === UNRESOLVED) {\n        // parent promise is unresolved.\n        const asyncTestZoneSpec = Zone.current.get('AsyncTestZoneSpec');\n\n        if (asyncTestZoneSpec) {\n          asyncTestZoneSpec.unresolvedChainedPromiseCount++;\n          chained[symbolParentUnresolved] = true;\n        }\n      }\n\n      return chained;\n    };\n  };\n\n  Promise[api.symbol('unPatchPromiseForTest')] = function unpatchPromiseForTest() {\n    // restore origin then\n    const oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n\n    if (oriThen) {\n      Promise.prototype.then = oriThen;\n      Promise[Zone.__symbol__('ZonePromiseThen')] = undefined;\n    }\n  };\n});","map":{"version":3,"names":["NEWLINE","IGNORE_FRAMES","creationTrace","ERROR_TAG","SEP_TAG","sepTemplate","LongStackTrace","constructor","error","getStacktrace","timestamp","Date","getStacktraceWithUncaughtError","Error","getStacktraceWithCaughtError","err","caughtError","stack","getFrames","split","addErrorStack","lines","trace","i","length","frame","hasOwnProperty","push","renderLongStackTrace","frames","longTrace","trim","getTime","traceFrames","lastTime","separator","replace","join","stackTracesEnabled","stackTraceLimit","Zone","name","longStackTraceLimit","getLongStackTrace","undefined","__symbol__","onScheduleTask","parentZoneDelegate","currentZone","targetZone","task","currentTask","data","concat","type","Object","assign","scheduleTask","onHandleError","parentTask","longStack","handleError","captureStackTraces","stackTraces","count","computeIgnoreFrames","frames1","frames2","frame1","indexOf","match","frame2","ProxyZoneSpec","defaultSpecDelegate","_delegateSpec","properties","propertyKeys","lastTaskState","isNeedToTriggerHasTask","tasks","setDelegate","get","current","isLoaded","assertPresent","delegateSpec","isNewDelegate","forEach","key","keys","k","macroTask","microTask","getDelegate","resetDelegate","tryTriggerHasTask","onHasTask","removeFromTasks","splice","getAndClearPendingTasksInfo","taskInfo","map","dataInfo","source","pendingTasksInfo","onFork","zoneSpec","fork","onIntercept","delegate","intercept","onInvoke","applyThis","applyArgs","invoke","onInvokeTask","invokeTask","onCancelTask","cancelTask","target","hasTaskState","hasTask","SyncTestZoneSpec","namePrefix","runZone","__load_patch","global","api","__extends","d","b","p","__","prototype","create","jest","jasmine","ambientZone","syncZone","symbol","disablePatchingJasmineClock","enableAutoFakeAsyncWhenClockPatched","ignoreUnhandledRejection","globalErrors","GlobalErrors","instance","originalInstall","install","originalHandlers","process","listeners","r","apply","arguments","removeAllListeners","h","on","jasmineEnv","getEnv","methodName","originalJasmineFn","description","specDefinitions","call","wrapDescribeInZone","timeout","wrapTestInZone","originalClockFn","clock","originalTick","tick","fakeAsyncZoneSpec","originalMockDate","mockDate","dateTime","setFakeBaseSystemTime","FakeAsyncTestZoneSpec","originalCreateSpyObj","createSpyObj","args","Array","slice","propertyNames","spyObj","defineProperty","obj","attributes","configurable","enumerable","describeBody","run","runInTestZone","testBody","queueRunner","done","isClockInstalled","testProxyZoneSpec","testProxyZone","fakeAsyncModule","fakeAsync","QueueRunner","_super","ZoneQueueRunner","attrs","onComplete","fn","scheduleMicroTask","nativeSetTimeout","nativeClearTimeout","setTimeout","clearTimeout","UserContext","userContext","onException","message","proxyZoneSpec","execute","zone","isChildOfAmbientZone","parent","context","rootZone","proxyZone","wrapDescribeFactoryInZone","originalJestFn","tableArgs","originalDescribeFn","wrapTestFactoryInZone","isTestFunc","wrappedFunc","isFakeAsync","writable","each","describe","only","fdescribe","skip","xdescribe","todo","it","fit","xit","test","patchJestObject","Timer","isModern","isPatchingFakeTimer","isInTestFunc","patchMethod","self","getRealSystemTime","flushMicrotasks","flush","flushOnlyPendingTimers","tickToNext","removeAllTimers","getTimerCount","Mocha","testZone","suiteZone","mochaOriginal","after","afterEach","before","beforeEach","modifyArguments","syncTest","asyncTest","arg","toString","wrapSuiteInZone","suite","specify","xspecify","suiteTeardown","teardown","suiteSetup","setup","originalRunTest","originalRun","Runner","runTest","e","_global","AsyncTestZoneSpec","finishCallback","failCallback","_pendingMicroTasks","_pendingMacroTasks","_alreadyErrored","_isSync","entryFunction","unresolvedChainedPromiseCount","supportWaitUnresolvedChainedPromise","isUnresolvedChainedPromisePending","_finishCallbackIfDone","patchPromiseForTest","Promise","unPatchPromiseForTest","symbolParentUnresolved","_taskCounts","result","change","window","fail","getZoneWith","previousDelegate","testZoneSpec","runGuarded","OriginalDate","FakeDate","setTime","now","fakeAsyncTestZoneSpec","getFakeSystemTime","UTC","parse","timers","setInterval","clearInterval","Scheduler","_schedulerQueue","_currentTickTime","_currentFakeBaseSystemTime","_currentTickRequeuePeriodicEntries","getCurrentTickTime","fakeBaseSystemTime","scheduleFunction","cb","delay","options","isPeriodic","isRequestAnimationFrame","id","isRequeuePeriodic","currentId","nextId","endTime","newEntry","func","currentEntry","removeScheduledFunctionWithId","removeAll","step","doTick","tickOptions","startTime","targetTask","millis","finalTime","lastCurrentTime","processNewMacroTasksSynchronously","schedulerQueue","shift","idx","retval","lastTask","limit","flushPeriodic","flushNonPeriodic","filter","trackPendingRequestAnimationFrame","macroTaskOptions","_scheduler","_microtasks","_lastError","_uncaughtPromiseErrors","pendingPeriodicTimers","pendingTimers","patchDateLocked","assertInZone","_fnAndFlush","completers","onSuccess","onError","_removeTimer","index","_dequeueTimer","_requeuePeriodicTimer","interval","_dequeuePeriodicTimer","_setTimeout","isTimer","removeTimerFn","_clearTimeout","_setInterval","_clearInterval","_resetLastErrorAndThrow","realTime","patchDate","checkTimerPatch","resetDate","lockDatePatch","unlockDatePatch","steps","flushErrors","microtask","elapsed","additionalArgs","callbackIndex","cbIdx","macroTaskOption","findMacroTaskOption","callbackArgs","handleId","callback","getProxyZoneSpec","_fakeAsyncTestZoneSpec","resetFakeAsyncZone","fakeAsyncFn","res","lastProxyZoneSpec","_getFakeAsyncZoneSpec","ignoreNestedTimeout","maxTurns","discardPeriodicTasks","symbolState","UNRESOLVED","oriThen","then","chained","asyncTestZoneSpec","unpatchPromiseForTest"],"sources":["/Users/olgabondarenko/Desktop/code/oh-my-food/node_modules/zone.js/fesm2015/zone-testing.js"],"sourcesContent":["'use strict';\n/**\n * @license Angular v14.0.0-next.5\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview\n * @suppress {globalThis}\n */\nconst NEWLINE = '\\n';\nconst IGNORE_FRAMES = {};\nconst creationTrace = '__creationTrace__';\nconst ERROR_TAG = 'STACKTRACE TRACKING';\nconst SEP_TAG = '__SEP_TAG__';\nlet sepTemplate = SEP_TAG + '@[native]';\nclass LongStackTrace {\n    constructor() {\n        this.error = getStacktrace();\n        this.timestamp = new Date();\n    }\n}\nfunction getStacktraceWithUncaughtError() {\n    return new Error(ERROR_TAG);\n}\nfunction getStacktraceWithCaughtError() {\n    try {\n        throw getStacktraceWithUncaughtError();\n    }\n    catch (err) {\n        return err;\n    }\n}\n// Some implementations of exception handling don't create a stack trace if the exception\n// isn't thrown, however it's faster not to actually throw the exception.\nconst error = getStacktraceWithUncaughtError();\nconst caughtError = getStacktraceWithCaughtError();\nconst getStacktrace = error.stack ?\n    getStacktraceWithUncaughtError :\n    (caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError);\nfunction getFrames(error) {\n    return error.stack ? error.stack.split(NEWLINE) : [];\n}\nfunction addErrorStack(lines, error) {\n    let trace = getFrames(error);\n    for (let i = 0; i < trace.length; i++) {\n        const frame = trace[i];\n        // Filter out the Frames which are part of stack capturing.\n        if (!IGNORE_FRAMES.hasOwnProperty(frame)) {\n            lines.push(trace[i]);\n        }\n    }\n}\nfunction renderLongStackTrace(frames, stack) {\n    const longTrace = [stack ? stack.trim() : ''];\n    if (frames) {\n        let timestamp = new Date().getTime();\n        for (let i = 0; i < frames.length; i++) {\n            const traceFrames = frames[i];\n            const lastTime = traceFrames.timestamp;\n            let separator = `____________________Elapsed ${timestamp - lastTime.getTime()} ms; At: ${lastTime}`;\n            separator = separator.replace(/[^\\w\\d]/g, '_');\n            longTrace.push(sepTemplate.replace(SEP_TAG, separator));\n            addErrorStack(longTrace, traceFrames.error);\n            timestamp = lastTime.getTime();\n        }\n    }\n    return longTrace.join(NEWLINE);\n}\n// if Error.stackTraceLimit is 0, means stack trace\n// is disabled, so we don't need to generate long stack trace\n// this will improve performance in some test(some test will\n// set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\nfunction stackTracesEnabled() {\n    // Cast through any since this property only exists on Error in the nodejs\n    // typings.\n    return Error.stackTraceLimit > 0;\n}\nZone['longStackTraceZoneSpec'] = {\n    name: 'long-stack-trace',\n    longStackTraceLimit: 10,\n    // add a getLongStackTrace method in spec to\n    // handle handled reject promise error.\n    getLongStackTrace: function (error) {\n        if (!error) {\n            return undefined;\n        }\n        const trace = error[Zone.__symbol__('currentTaskTrace')];\n        if (!trace) {\n            return error.stack;\n        }\n        return renderLongStackTrace(trace, error.stack);\n    },\n    onScheduleTask: function (parentZoneDelegate, currentZone, targetZone, task) {\n        if (stackTracesEnabled()) {\n            const currentTask = Zone.currentTask;\n            let trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];\n            trace = [new LongStackTrace()].concat(trace);\n            if (trace.length > this.longStackTraceLimit) {\n                trace.length = this.longStackTraceLimit;\n            }\n            if (!task.data)\n                task.data = {};\n            if (task.type === 'eventTask') {\n                // Fix issue https://github.com/angular/zone.js/issues/1195,\n                // For event task of browser, by default, all task will share a\n                // singleton instance of data object, we should create a new one here\n                // The cast to `any` is required to workaround a closure bug which wrongly applies\n                // URL sanitization rules to .data access.\n                task.data = Object.assign({}, task.data);\n            }\n            task.data[creationTrace] = trace;\n        }\n        return parentZoneDelegate.scheduleTask(targetZone, task);\n    },\n    onHandleError: function (parentZoneDelegate, currentZone, targetZone, error) {\n        if (stackTracesEnabled()) {\n            const parentTask = Zone.currentTask || error.task;\n            if (error instanceof Error && parentTask) {\n                const longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);\n                try {\n                    error.stack = error.longStack = longStack;\n                }\n                catch (err) {\n                }\n            }\n        }\n        return parentZoneDelegate.handleError(targetZone, error);\n    }\n};\nfunction captureStackTraces(stackTraces, count) {\n    if (count > 0) {\n        stackTraces.push(getFrames((new LongStackTrace()).error));\n        captureStackTraces(stackTraces, count - 1);\n    }\n}\nfunction computeIgnoreFrames() {\n    if (!stackTracesEnabled()) {\n        return;\n    }\n    const frames = [];\n    captureStackTraces(frames, 2);\n    const frames1 = frames[0];\n    const frames2 = frames[1];\n    for (let i = 0; i < frames1.length; i++) {\n        const frame1 = frames1[i];\n        if (frame1.indexOf(ERROR_TAG) == -1) {\n            let match = frame1.match(/^\\s*at\\s+/);\n            if (match) {\n                sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';\n                break;\n            }\n        }\n    }\n    for (let i = 0; i < frames1.length; i++) {\n        const frame1 = frames1[i];\n        const frame2 = frames2[i];\n        if (frame1 === frame2) {\n            IGNORE_FRAMES[frame1] = true;\n        }\n        else {\n            break;\n        }\n    }\n}\ncomputeIgnoreFrames();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass ProxyZoneSpec {\n    constructor(defaultSpecDelegate = null) {\n        this.defaultSpecDelegate = defaultSpecDelegate;\n        this.name = 'ProxyZone';\n        this._delegateSpec = null;\n        this.properties = { 'ProxyZoneSpec': this };\n        this.propertyKeys = null;\n        this.lastTaskState = null;\n        this.isNeedToTriggerHasTask = false;\n        this.tasks = [];\n        this.setDelegate(defaultSpecDelegate);\n    }\n    static get() {\n        return Zone.current.get('ProxyZoneSpec');\n    }\n    static isLoaded() {\n        return ProxyZoneSpec.get() instanceof ProxyZoneSpec;\n    }\n    static assertPresent() {\n        if (!ProxyZoneSpec.isLoaded()) {\n            throw new Error(`Expected to be running in 'ProxyZone', but it was not found.`);\n        }\n        return ProxyZoneSpec.get();\n    }\n    setDelegate(delegateSpec) {\n        const isNewDelegate = this._delegateSpec !== delegateSpec;\n        this._delegateSpec = delegateSpec;\n        this.propertyKeys && this.propertyKeys.forEach((key) => delete this.properties[key]);\n        this.propertyKeys = null;\n        if (delegateSpec && delegateSpec.properties) {\n            this.propertyKeys = Object.keys(delegateSpec.properties);\n            this.propertyKeys.forEach((k) => this.properties[k] = delegateSpec.properties[k]);\n        }\n        // if a new delegateSpec was set, check if we need to trigger hasTask\n        if (isNewDelegate && this.lastTaskState &&\n            (this.lastTaskState.macroTask || this.lastTaskState.microTask)) {\n            this.isNeedToTriggerHasTask = true;\n        }\n    }\n    getDelegate() {\n        return this._delegateSpec;\n    }\n    resetDelegate() {\n        this.getDelegate();\n        this.setDelegate(this.defaultSpecDelegate);\n    }\n    tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone) {\n        if (this.isNeedToTriggerHasTask && this.lastTaskState) {\n            // last delegateSpec has microTask or macroTask\n            // should call onHasTask in current delegateSpec\n            this.isNeedToTriggerHasTask = false;\n            this.onHasTask(parentZoneDelegate, currentZone, targetZone, this.lastTaskState);\n        }\n    }\n    removeFromTasks(task) {\n        if (!this.tasks) {\n            return;\n        }\n        for (let i = 0; i < this.tasks.length; i++) {\n            if (this.tasks[i] === task) {\n                this.tasks.splice(i, 1);\n                return;\n            }\n        }\n    }\n    getAndClearPendingTasksInfo() {\n        if (this.tasks.length === 0) {\n            return '';\n        }\n        const taskInfo = this.tasks.map((task) => {\n            const dataInfo = task.data &&\n                Object.keys(task.data)\n                    .map((key) => {\n                    return key + ':' + task.data[key];\n                })\n                    .join(',');\n            return `type: ${task.type}, source: ${task.source}, args: {${dataInfo}}`;\n        });\n        const pendingTasksInfo = '--Pending async tasks are: [' + taskInfo + ']';\n        // clear tasks\n        this.tasks = [];\n        return pendingTasksInfo;\n    }\n    onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec) {\n        if (this._delegateSpec && this._delegateSpec.onFork) {\n            return this._delegateSpec.onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec);\n        }\n        else {\n            return parentZoneDelegate.fork(targetZone, zoneSpec);\n        }\n    }\n    onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source) {\n        if (this._delegateSpec && this._delegateSpec.onIntercept) {\n            return this._delegateSpec.onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source);\n        }\n        else {\n            return parentZoneDelegate.intercept(targetZone, delegate, source);\n        }\n    }\n    onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n        this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n        if (this._delegateSpec && this._delegateSpec.onInvoke) {\n            return this._delegateSpec.onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source);\n        }\n        else {\n            return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n        }\n    }\n    onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n        if (this._delegateSpec && this._delegateSpec.onHandleError) {\n            return this._delegateSpec.onHandleError(parentZoneDelegate, currentZone, targetZone, error);\n        }\n        else {\n            return parentZoneDelegate.handleError(targetZone, error);\n        }\n    }\n    onScheduleTask(parentZoneDelegate, currentZone, targetZone, task) {\n        if (task.type !== 'eventTask') {\n            this.tasks.push(task);\n        }\n        if (this._delegateSpec && this._delegateSpec.onScheduleTask) {\n            return this._delegateSpec.onScheduleTask(parentZoneDelegate, currentZone, targetZone, task);\n        }\n        else {\n            return parentZoneDelegate.scheduleTask(targetZone, task);\n        }\n    }\n    onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {\n        if (task.type !== 'eventTask') {\n            this.removeFromTasks(task);\n        }\n        this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n        if (this._delegateSpec && this._delegateSpec.onInvokeTask) {\n            return this._delegateSpec.onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs);\n        }\n        else {\n            return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n        }\n    }\n    onCancelTask(parentZoneDelegate, currentZone, targetZone, task) {\n        if (task.type !== 'eventTask') {\n            this.removeFromTasks(task);\n        }\n        this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n        if (this._delegateSpec && this._delegateSpec.onCancelTask) {\n            return this._delegateSpec.onCancelTask(parentZoneDelegate, currentZone, targetZone, task);\n        }\n        else {\n            return parentZoneDelegate.cancelTask(targetZone, task);\n        }\n    }\n    onHasTask(delegate, current, target, hasTaskState) {\n        this.lastTaskState = hasTaskState;\n        if (this._delegateSpec && this._delegateSpec.onHasTask) {\n            this._delegateSpec.onHasTask(delegate, current, target, hasTaskState);\n        }\n        else {\n            delegate.hasTask(target, hasTaskState);\n        }\n    }\n}\n// Export the class so that new instances can be created with proper\n// constructor params.\nZone['ProxyZoneSpec'] = ProxyZoneSpec;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass SyncTestZoneSpec {\n    constructor(namePrefix) {\n        this.runZone = Zone.current;\n        this.name = 'syncTestZone for ' + namePrefix;\n    }\n    onScheduleTask(delegate, current, target, task) {\n        switch (task.type) {\n            case 'microTask':\n            case 'macroTask':\n                throw new Error(`Cannot call ${task.source} from within a sync test.`);\n            case 'eventTask':\n                task = delegate.scheduleTask(target, task);\n                break;\n        }\n        return task;\n    }\n}\n// Export the class so that new instances can be created with proper\n// constructor params.\nZone['SyncTestZoneSpec'] = SyncTestZoneSpec;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nZone.__load_patch('jasmine', (global, Zone, api) => {\n    const __extends = function (d, b) {\n        for (const p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p];\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());\n    };\n    // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n    // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n    if (!Zone)\n        throw new Error('Missing: zone.js');\n    if (typeof jest !== 'undefined') {\n        // return if jasmine is a light implementation inside jest\n        // in this case, we are running inside jest not jasmine\n        return;\n    }\n    if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n        return;\n    }\n    jasmine['__zone_patch__'] = true;\n    const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n    const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    if (!SyncTestZoneSpec)\n        throw new Error('Missing: SyncTestZoneSpec');\n    if (!ProxyZoneSpec)\n        throw new Error('Missing: ProxyZoneSpec');\n    const ambientZone = Zone.current;\n    // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n    // error if any asynchronous operations are attempted inside of a `describe` but outside of\n    // a `beforeEach` or `it`.\n    const syncZone = ambientZone.fork(new SyncTestZoneSpec('jasmine.describe'));\n    const symbol = Zone.__symbol__;\n    // whether patch jasmine clock when in fakeAsync\n    const disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true;\n    // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n    // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also\n    // automatically disable the auto jump into fakeAsync feature\n    const enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock &&\n        ((global[symbol('fakeAsyncPatchLock')] === true) ||\n            (global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true));\n    const ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n    if (!ignoreUnhandledRejection) {\n        const globalErrors = jasmine.GlobalErrors;\n        if (globalErrors && !jasmine[symbol('GlobalErrors')]) {\n            jasmine[symbol('GlobalErrors')] = globalErrors;\n            jasmine.GlobalErrors = function () {\n                const instance = new globalErrors();\n                const originalInstall = instance.install;\n                if (originalInstall && !instance[symbol('install')]) {\n                    instance[symbol('install')] = originalInstall;\n                    instance.install = function () {\n                        const originalHandlers = process.listeners('unhandledRejection');\n                        const r = originalInstall.apply(this, arguments);\n                        process.removeAllListeners('unhandledRejection');\n                        if (originalHandlers) {\n                            originalHandlers.forEach(h => process.on('unhandledRejection', h));\n                        }\n                        return r;\n                    };\n                }\n                return instance;\n            };\n        }\n    }\n    // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n    const jasmineEnv = jasmine.getEnv();\n    ['describe', 'xdescribe', 'fdescribe'].forEach(methodName => {\n        let originalJasmineFn = jasmineEnv[methodName];\n        jasmineEnv[methodName] = function (description, specDefinitions) {\n            return originalJasmineFn.call(this, description, wrapDescribeInZone(specDefinitions));\n        };\n    });\n    ['it', 'xit', 'fit'].forEach(methodName => {\n        let originalJasmineFn = jasmineEnv[methodName];\n        jasmineEnv[symbol(methodName)] = originalJasmineFn;\n        jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n            arguments[1] = wrapTestInZone(specDefinitions);\n            return originalJasmineFn.apply(this, arguments);\n        };\n    });\n    ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(methodName => {\n        let originalJasmineFn = jasmineEnv[methodName];\n        jasmineEnv[symbol(methodName)] = originalJasmineFn;\n        jasmineEnv[methodName] = function (specDefinitions, timeout) {\n            arguments[0] = wrapTestInZone(specDefinitions);\n            return originalJasmineFn.apply(this, arguments);\n        };\n    });\n    if (!disablePatchingJasmineClock) {\n        // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n        // they can work properly in FakeAsyncTest\n        const originalClockFn = (jasmine[symbol('clock')] = jasmine['clock']);\n        jasmine['clock'] = function () {\n            const clock = originalClockFn.apply(this, arguments);\n            if (!clock[symbol('patched')]) {\n                clock[symbol('patched')] = symbol('patched');\n                const originalTick = (clock[symbol('tick')] = clock.tick);\n                clock.tick = function () {\n                    const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n                    }\n                    return originalTick.apply(this, arguments);\n                };\n                const originalMockDate = (clock[symbol('mockDate')] = clock.mockDate);\n                clock.mockDate = function () {\n                    const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        const dateTime = arguments.length > 0 ? arguments[0] : new Date();\n                        return fakeAsyncZoneSpec.setFakeBaseSystemTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] :\n                            arguments);\n                    }\n                    return originalMockDate.apply(this, arguments);\n                };\n                // for auto go into fakeAsync feature, we need the flag to enable it\n                if (enableAutoFakeAsyncWhenClockPatched) {\n                    ['install', 'uninstall'].forEach(methodName => {\n                        const originalClockFn = (clock[symbol(methodName)] = clock[methodName]);\n                        clock[methodName] = function () {\n                            const FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n                            if (FakeAsyncTestZoneSpec) {\n                                jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                                return;\n                            }\n                            return originalClockFn.apply(this, arguments);\n                        };\n                    });\n                }\n            }\n            return clock;\n        };\n    }\n    // monkey patch createSpyObj to make properties enumerable to true\n    if (!jasmine[Zone.__symbol__('createSpyObj')]) {\n        const originalCreateSpyObj = jasmine.createSpyObj;\n        jasmine[Zone.__symbol__('createSpyObj')] = originalCreateSpyObj;\n        jasmine.createSpyObj = function () {\n            const args = Array.prototype.slice.call(arguments);\n            const propertyNames = args.length >= 3 ? args[2] : null;\n            let spyObj;\n            if (propertyNames) {\n                const defineProperty = Object.defineProperty;\n                Object.defineProperty = function (obj, p, attributes) {\n                    return defineProperty.call(this, obj, p, Object.assign(Object.assign({}, attributes), { configurable: true, enumerable: true }));\n                };\n                try {\n                    spyObj = originalCreateSpyObj.apply(this, args);\n                }\n                finally {\n                    Object.defineProperty = defineProperty;\n                }\n            }\n            else {\n                spyObj = originalCreateSpyObj.apply(this, args);\n            }\n            return spyObj;\n        };\n    }\n    /**\n     * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n     * synchronous-only zone.\n     */\n    function wrapDescribeInZone(describeBody) {\n        return function () {\n            return syncZone.run(describeBody, this, arguments);\n        };\n    }\n    function runInTestZone(testBody, applyThis, queueRunner, done) {\n        const isClockInstalled = !!jasmine[symbol('clockInstalled')];\n        queueRunner.testProxyZoneSpec;\n        const testProxyZone = queueRunner.testProxyZone;\n        if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n            // auto run a fakeAsync\n            const fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n            if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n                testBody = fakeAsyncModule.fakeAsync(testBody);\n            }\n        }\n        if (done) {\n            return testProxyZone.run(testBody, applyThis, [done]);\n        }\n        else {\n            return testProxyZone.run(testBody, applyThis);\n        }\n    }\n    /**\n     * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n     * execute in a ProxyZone zone.\n     * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n     */\n    function wrapTestInZone(testBody) {\n        // The `done` callback is only passed through if the function expects at least one argument.\n        // Note we have to make a function with correct number of arguments, otherwise jasmine will\n        // think that all functions are sync or async.\n        return (testBody && (testBody.length ? function (done) {\n            return runInTestZone(testBody, this, this.queueRunner, done);\n        } : function () {\n            return runInTestZone(testBody, this, this.queueRunner);\n        }));\n    }\n    const QueueRunner = jasmine.QueueRunner;\n    jasmine.QueueRunner = (function (_super) {\n        __extends(ZoneQueueRunner, _super);\n        function ZoneQueueRunner(attrs) {\n            if (attrs.onComplete) {\n                attrs.onComplete = (fn => () => {\n                    // All functions are done, clear the test zone.\n                    this.testProxyZone = null;\n                    this.testProxyZoneSpec = null;\n                    ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n                })(attrs.onComplete);\n            }\n            const nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n            const nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n            if (nativeSetTimeout) {\n                // should run setTimeout inside jasmine outside of zone\n                attrs.timeout = {\n                    setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n                    clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout\n                };\n            }\n            // create a userContext to hold the queueRunner itself\n            // so we can access the testProxy in it/xit/beforeEach ...\n            if (jasmine.UserContext) {\n                if (!attrs.userContext) {\n                    attrs.userContext = new jasmine.UserContext();\n                }\n                attrs.userContext.queueRunner = this;\n            }\n            else {\n                if (!attrs.userContext) {\n                    attrs.userContext = {};\n                }\n                attrs.userContext.queueRunner = this;\n            }\n            // patch attrs.onException\n            const onException = attrs.onException;\n            attrs.onException = function (error) {\n                if (error &&\n                    error.message ===\n                        'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n                    // jasmine timeout, we can make the error message more\n                    // reasonable to tell what tasks are pending\n                    const proxyZoneSpec = this && this.testProxyZoneSpec;\n                    if (proxyZoneSpec) {\n                        const pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n                        try {\n                            // try catch here in case error.message is not writable\n                            error.message += pendingTasksInfo;\n                        }\n                        catch (err) {\n                        }\n                    }\n                }\n                if (onException) {\n                    onException.call(this, error);\n                }\n            };\n            _super.call(this, attrs);\n        }\n        ZoneQueueRunner.prototype.execute = function () {\n            let zone = Zone.current;\n            let isChildOfAmbientZone = false;\n            while (zone) {\n                if (zone === ambientZone) {\n                    isChildOfAmbientZone = true;\n                    break;\n                }\n                zone = zone.parent;\n            }\n            if (!isChildOfAmbientZone)\n                throw new Error('Unexpected Zone: ' + Zone.current.name);\n            // This is the zone which will be used for running individual tests.\n            // It will be a proxy zone, so that the tests function can retroactively install\n            // different zones.\n            // Example:\n            //   - In beforeEach() do childZone = Zone.current.fork(...);\n            //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n            //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n            //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n            //     fakeAsync behavior to the childZone.\n            this.testProxyZoneSpec = new ProxyZoneSpec();\n            this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n            if (!Zone.currentTask) {\n                // if we are not running in a task then if someone would register a\n                // element.addEventListener and then calling element.click() the\n                // addEventListener callback would think that it is the top most task and would\n                // drain the microtask queue on element.click() which would be incorrect.\n                // For this reason we always force a task when running jasmine tests.\n                Zone.current.scheduleMicroTask('jasmine.execute().forceTask', () => QueueRunner.prototype.execute.call(this));\n            }\n            else {\n                _super.prototype.execute.call(this);\n            }\n        };\n        return ZoneQueueRunner;\n    })(QueueRunner);\n});\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nZone.__load_patch('jest', (context, Zone, api) => {\n    if (typeof jest === 'undefined' || jest['__zone_patch__']) {\n        return;\n    }\n    jest['__zone_patch__'] = true;\n    const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n    if (!ProxyZoneSpec) {\n        throw new Error('Missing ProxyZoneSpec');\n    }\n    const rootZone = Zone.current;\n    const syncZone = rootZone.fork(new SyncTestZoneSpec('jest.describe'));\n    const proxyZoneSpec = new ProxyZoneSpec();\n    const proxyZone = rootZone.fork(proxyZoneSpec);\n    function wrapDescribeFactoryInZone(originalJestFn) {\n        return function (...tableArgs) {\n            const originalDescribeFn = originalJestFn.apply(this, tableArgs);\n            return function (...args) {\n                args[1] = wrapDescribeInZone(args[1]);\n                return originalDescribeFn.apply(this, args);\n            };\n        };\n    }\n    function wrapTestFactoryInZone(originalJestFn) {\n        return function (...tableArgs) {\n            return function (...args) {\n                args[1] = wrapTestInZone(args[1]);\n                return originalJestFn.apply(this, tableArgs).apply(this, args);\n            };\n        };\n    }\n    /**\n     * Gets a function wrapping the body of a jest `describe` block to execute in a\n     * synchronous-only zone.\n     */\n    function wrapDescribeInZone(describeBody) {\n        return function (...args) {\n            return syncZone.run(describeBody, this, args);\n        };\n    }\n    /**\n     * Gets a function wrapping the body of a jest `it/beforeEach/afterEach` block to\n     * execute in a ProxyZone zone.\n     * This will run in the `proxyZone`.\n     */\n    function wrapTestInZone(testBody, isTestFunc = false) {\n        if (typeof testBody !== 'function') {\n            return testBody;\n        }\n        const wrappedFunc = function () {\n            if (Zone[api.symbol('useFakeTimersCalled')] === true && testBody &&\n                !testBody.isFakeAsync) {\n                // jest.useFakeTimers is called, run into fakeAsyncTest automatically.\n                const fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n                if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n                    testBody = fakeAsyncModule.fakeAsync(testBody);\n                }\n            }\n            proxyZoneSpec.isTestFunc = isTestFunc;\n            return proxyZone.run(testBody, null, arguments);\n        };\n        // Update the length of wrappedFunc to be the same as the length of the testBody\n        // So jest core can handle whether the test function has `done()` or not correctly\n        Object.defineProperty(wrappedFunc, 'length', { configurable: true, writable: true, enumerable: false });\n        wrappedFunc.length = testBody.length;\n        return wrappedFunc;\n    }\n    ['describe', 'xdescribe', 'fdescribe'].forEach(methodName => {\n        let originalJestFn = context[methodName];\n        if (context[Zone.__symbol__(methodName)]) {\n            return;\n        }\n        context[Zone.__symbol__(methodName)] = originalJestFn;\n        context[methodName] = function (...args) {\n            args[1] = wrapDescribeInZone(args[1]);\n            return originalJestFn.apply(this, args);\n        };\n        context[methodName].each = wrapDescribeFactoryInZone(originalJestFn.each);\n    });\n    context.describe.only = context.fdescribe;\n    context.describe.skip = context.xdescribe;\n    ['it', 'xit', 'fit', 'test', 'xtest'].forEach(methodName => {\n        let originalJestFn = context[methodName];\n        if (context[Zone.__symbol__(methodName)]) {\n            return;\n        }\n        context[Zone.__symbol__(methodName)] = originalJestFn;\n        context[methodName] = function (...args) {\n            args[1] = wrapTestInZone(args[1], true);\n            return originalJestFn.apply(this, args);\n        };\n        context[methodName].each = wrapTestFactoryInZone(originalJestFn.each);\n        context[methodName].todo = originalJestFn.todo;\n    });\n    context.it.only = context.fit;\n    context.it.skip = context.xit;\n    context.test.only = context.fit;\n    context.test.skip = context.xit;\n    ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(methodName => {\n        let originalJestFn = context[methodName];\n        if (context[Zone.__symbol__(methodName)]) {\n            return;\n        }\n        context[Zone.__symbol__(methodName)] = originalJestFn;\n        context[methodName] = function (...args) {\n            args[0] = wrapTestInZone(args[0]);\n            return originalJestFn.apply(this, args);\n        };\n    });\n    Zone.patchJestObject = function patchJestObject(Timer, isModern = false) {\n        // check whether currently the test is inside fakeAsync()\n        function isPatchingFakeTimer() {\n            const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n            return !!fakeAsyncZoneSpec;\n        }\n        // check whether the current function is inside `test/it` or other methods\n        // such as `describe/beforeEach`\n        function isInTestFunc() {\n            const proxyZoneSpec = Zone.current.get('ProxyZoneSpec');\n            return proxyZoneSpec && proxyZoneSpec.isTestFunc;\n        }\n        if (Timer[api.symbol('fakeTimers')]) {\n            return;\n        }\n        Timer[api.symbol('fakeTimers')] = true;\n        // patch jest fakeTimer internal method to make sure no console.warn print out\n        api.patchMethod(Timer, '_checkFakeTimers', delegate => {\n            return function (self, args) {\n                if (isPatchingFakeTimer()) {\n                    return true;\n                }\n                else {\n                    return delegate.apply(self, args);\n                }\n            };\n        });\n        // patch useFakeTimers(), set useFakeTimersCalled flag, and make test auto run into fakeAsync\n        api.patchMethod(Timer, 'useFakeTimers', delegate => {\n            return function (self, args) {\n                Zone[api.symbol('useFakeTimersCalled')] = true;\n                if (isModern || isInTestFunc()) {\n                    return delegate.apply(self, args);\n                }\n                return self;\n            };\n        });\n        // patch useRealTimers(), unset useFakeTimers flag\n        api.patchMethod(Timer, 'useRealTimers', delegate => {\n            return function (self, args) {\n                Zone[api.symbol('useFakeTimersCalled')] = false;\n                if (isModern || isInTestFunc()) {\n                    return delegate.apply(self, args);\n                }\n                return self;\n            };\n        });\n        // patch setSystemTime(), call setCurrentRealTime() in the fakeAsyncTest\n        api.patchMethod(Timer, 'setSystemTime', delegate => {\n            return function (self, args) {\n                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n                    fakeAsyncZoneSpec.setFakeBaseSystemTime(args[0]);\n                }\n                else {\n                    return delegate.apply(self, args);\n                }\n            };\n        });\n        // patch getSystemTime(), call getCurrentRealTime() in the fakeAsyncTest\n        api.patchMethod(Timer, 'getRealSystemTime', delegate => {\n            return function (self, args) {\n                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n                    return fakeAsyncZoneSpec.getRealSystemTime();\n                }\n                else {\n                    return delegate.apply(self, args);\n                }\n            };\n        });\n        // patch runAllTicks(), run all microTasks inside fakeAsync\n        api.patchMethod(Timer, 'runAllTicks', delegate => {\n            return function (self, args) {\n                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (fakeAsyncZoneSpec) {\n                    fakeAsyncZoneSpec.flushMicrotasks();\n                }\n                else {\n                    return delegate.apply(self, args);\n                }\n            };\n        });\n        // patch runAllTimers(), run all macroTasks inside fakeAsync\n        api.patchMethod(Timer, 'runAllTimers', delegate => {\n            return function (self, args) {\n                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (fakeAsyncZoneSpec) {\n                    fakeAsyncZoneSpec.flush(100, true);\n                }\n                else {\n                    return delegate.apply(self, args);\n                }\n            };\n        });\n        // patch advanceTimersByTime(), call tick() in the fakeAsyncTest\n        api.patchMethod(Timer, 'advanceTimersByTime', delegate => {\n            return function (self, args) {\n                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (fakeAsyncZoneSpec) {\n                    fakeAsyncZoneSpec.tick(args[0]);\n                }\n                else {\n                    return delegate.apply(self, args);\n                }\n            };\n        });\n        // patch runOnlyPendingTimers(), call flushOnlyPendingTimers() in the fakeAsyncTest\n        api.patchMethod(Timer, 'runOnlyPendingTimers', delegate => {\n            return function (self, args) {\n                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (fakeAsyncZoneSpec) {\n                    fakeAsyncZoneSpec.flushOnlyPendingTimers();\n                }\n                else {\n                    return delegate.apply(self, args);\n                }\n            };\n        });\n        // patch advanceTimersToNextTimer(), call tickToNext() in the fakeAsyncTest\n        api.patchMethod(Timer, 'advanceTimersToNextTimer', delegate => {\n            return function (self, args) {\n                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (fakeAsyncZoneSpec) {\n                    fakeAsyncZoneSpec.tickToNext(args[0]);\n                }\n                else {\n                    return delegate.apply(self, args);\n                }\n            };\n        });\n        // patch clearAllTimers(), call removeAllTimers() in the fakeAsyncTest\n        api.patchMethod(Timer, 'clearAllTimers', delegate => {\n            return function (self, args) {\n                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (fakeAsyncZoneSpec) {\n                    fakeAsyncZoneSpec.removeAllTimers();\n                }\n                else {\n                    return delegate.apply(self, args);\n                }\n            };\n        });\n        // patch getTimerCount(), call getTimerCount() in the fakeAsyncTest\n        api.patchMethod(Timer, 'getTimerCount', delegate => {\n            return function (self, args) {\n                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (fakeAsyncZoneSpec) {\n                    return fakeAsyncZoneSpec.getTimerCount();\n                }\n                else {\n                    return delegate.apply(self, args);\n                }\n            };\n        });\n    };\n});\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nZone.__load_patch('mocha', (global, Zone) => {\n    const Mocha = global.Mocha;\n    if (typeof Mocha === 'undefined') {\n        // return if Mocha is not available, because now zone-testing\n        // will load mocha patch with jasmine/jest patch\n        return;\n    }\n    if (typeof Zone === 'undefined') {\n        throw new Error('Missing Zone.js');\n    }\n    const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n    if (!ProxyZoneSpec) {\n        throw new Error('Missing ProxyZoneSpec');\n    }\n    if (Mocha['__zone_patch__']) {\n        throw new Error('\"Mocha\" has already been patched with \"Zone\".');\n    }\n    Mocha['__zone_patch__'] = true;\n    const rootZone = Zone.current;\n    const syncZone = rootZone.fork(new SyncTestZoneSpec('Mocha.describe'));\n    let testZone = null;\n    const suiteZone = rootZone.fork(new ProxyZoneSpec());\n    const mochaOriginal = {\n        after: global.after,\n        afterEach: global.afterEach,\n        before: global.before,\n        beforeEach: global.beforeEach,\n        describe: global.describe,\n        it: global.it\n    };\n    function modifyArguments(args, syncTest, asyncTest) {\n        for (let i = 0; i < args.length; i++) {\n            let arg = args[i];\n            if (typeof arg === 'function') {\n                // The `done` callback is only passed through if the function expects at\n                // least one argument.\n                // Note we have to make a function with correct number of arguments,\n                // otherwise mocha will\n                // think that all functions are sync or async.\n                args[i] = (arg.length === 0) ? syncTest(arg) : asyncTest(arg);\n                // Mocha uses toString to view the test body in the result list, make sure we return the\n                // correct function body\n                args[i].toString = function () {\n                    return arg.toString();\n                };\n            }\n        }\n        return args;\n    }\n    function wrapDescribeInZone(args) {\n        const syncTest = function (fn) {\n            return function () {\n                return syncZone.run(fn, this, arguments);\n            };\n        };\n        return modifyArguments(args, syncTest);\n    }\n    function wrapTestInZone(args) {\n        const asyncTest = function (fn) {\n            return function (done) {\n                return testZone.run(fn, this, [done]);\n            };\n        };\n        const syncTest = function (fn) {\n            return function () {\n                return testZone.run(fn, this);\n            };\n        };\n        return modifyArguments(args, syncTest, asyncTest);\n    }\n    function wrapSuiteInZone(args) {\n        const asyncTest = function (fn) {\n            return function (done) {\n                return suiteZone.run(fn, this, [done]);\n            };\n        };\n        const syncTest = function (fn) {\n            return function () {\n                return suiteZone.run(fn, this);\n            };\n        };\n        return modifyArguments(args, syncTest, asyncTest);\n    }\n    global.describe = global.suite = function () {\n        return mochaOriginal.describe.apply(this, wrapDescribeInZone(arguments));\n    };\n    global.xdescribe = global.suite.skip = function () {\n        return mochaOriginal.describe.skip.apply(this, wrapDescribeInZone(arguments));\n    };\n    global.describe.only = global.suite.only = function () {\n        return mochaOriginal.describe.only.apply(this, wrapDescribeInZone(arguments));\n    };\n    global.it = global.specify = global.test = function () {\n        return mochaOriginal.it.apply(this, wrapTestInZone(arguments));\n    };\n    global.xit = global.xspecify = function () {\n        return mochaOriginal.it.skip.apply(this, wrapTestInZone(arguments));\n    };\n    global.it.only = global.test.only = function () {\n        return mochaOriginal.it.only.apply(this, wrapTestInZone(arguments));\n    };\n    global.after = global.suiteTeardown = function () {\n        return mochaOriginal.after.apply(this, wrapSuiteInZone(arguments));\n    };\n    global.afterEach = global.teardown = function () {\n        return mochaOriginal.afterEach.apply(this, wrapTestInZone(arguments));\n    };\n    global.before = global.suiteSetup = function () {\n        return mochaOriginal.before.apply(this, wrapSuiteInZone(arguments));\n    };\n    global.beforeEach = global.setup = function () {\n        return mochaOriginal.beforeEach.apply(this, wrapTestInZone(arguments));\n    };\n    ((originalRunTest, originalRun) => {\n        Mocha.Runner.prototype.runTest = function (fn) {\n            Zone.current.scheduleMicroTask('mocha.forceTask', () => {\n                originalRunTest.call(this, fn);\n            });\n        };\n        Mocha.Runner.prototype.run = function (fn) {\n            this.on('test', (e) => {\n                testZone = rootZone.fork(new ProxyZoneSpec());\n            });\n            this.on('fail', (test, err) => {\n                const proxyZoneSpec = testZone && testZone.get('ProxyZoneSpec');\n                if (proxyZoneSpec && err) {\n                    try {\n                        // try catch here in case err.message is not writable\n                        err.message += proxyZoneSpec.getAndClearPendingTasksInfo();\n                    }\n                    catch (error) {\n                    }\n                }\n            });\n            return originalRun.call(this, fn);\n        };\n    })(Mocha.Runner.prototype.runTest, Mocha.Runner.prototype.run);\n});\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (_global) {\n    class AsyncTestZoneSpec {\n        constructor(finishCallback, failCallback, namePrefix) {\n            this.finishCallback = finishCallback;\n            this.failCallback = failCallback;\n            this._pendingMicroTasks = false;\n            this._pendingMacroTasks = false;\n            this._alreadyErrored = false;\n            this._isSync = false;\n            this.entryFunction = null;\n            this.runZone = Zone.current;\n            this.unresolvedChainedPromiseCount = 0;\n            this.supportWaitUnresolvedChainedPromise = false;\n            this.name = 'asyncTestZone for ' + namePrefix;\n            this.properties = { 'AsyncTestZoneSpec': this };\n            this.supportWaitUnresolvedChainedPromise =\n                _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n        }\n        isUnresolvedChainedPromisePending() {\n            return this.unresolvedChainedPromiseCount > 0;\n        }\n        _finishCallbackIfDone() {\n            if (!(this._pendingMicroTasks || this._pendingMacroTasks ||\n                (this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending()))) {\n                // We do this because we would like to catch unhandled rejected promises.\n                this.runZone.run(() => {\n                    setTimeout(() => {\n                        if (!this._alreadyErrored && !(this._pendingMicroTasks || this._pendingMacroTasks)) {\n                            this.finishCallback();\n                        }\n                    }, 0);\n                });\n            }\n        }\n        patchPromiseForTest() {\n            if (!this.supportWaitUnresolvedChainedPromise) {\n                return;\n            }\n            const patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n            if (patchPromiseForTest) {\n                patchPromiseForTest();\n            }\n        }\n        unPatchPromiseForTest() {\n            if (!this.supportWaitUnresolvedChainedPromise) {\n                return;\n            }\n            const unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n            if (unPatchPromiseForTest) {\n                unPatchPromiseForTest();\n            }\n        }\n        onScheduleTask(delegate, current, target, task) {\n            if (task.type !== 'eventTask') {\n                this._isSync = false;\n            }\n            if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n                // check whether the promise is a chained promise\n                if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n                    // chained promise is being scheduled\n                    this.unresolvedChainedPromiseCount--;\n                }\n            }\n            return delegate.scheduleTask(target, task);\n        }\n        onInvokeTask(delegate, current, target, task, applyThis, applyArgs) {\n            if (task.type !== 'eventTask') {\n                this._isSync = false;\n            }\n            return delegate.invokeTask(target, task, applyThis, applyArgs);\n        }\n        onCancelTask(delegate, current, target, task) {\n            if (task.type !== 'eventTask') {\n                this._isSync = false;\n            }\n            return delegate.cancelTask(target, task);\n        }\n        // Note - we need to use onInvoke at the moment to call finish when a test is\n        // fully synchronous. TODO(juliemr): remove this when the logic for\n        // onHasTask changes and it calls whenever the task queues are dirty.\n        // updated by(JiaLiPassion), only call finish callback when no task\n        // was scheduled/invoked/canceled.\n        onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n            if (!this.entryFunction) {\n                this.entryFunction = delegate;\n            }\n            try {\n                this._isSync = true;\n                return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n            }\n            finally {\n                parentZoneDelegate._taskCounts;\n                // We need to check the delegate is the same as entryFunction or not.\n                // Consider the following case.\n                //\n                // asyncTestZone.run(() => { // Here the delegate will be the entryFunction\n                //   Zone.current.run(() => { // Here the delegate will not be the entryFunction\n                //   });\n                // });\n                //\n                // We only want to check whether there are async tasks scheduled\n                // for the entry function.\n                if (this._isSync && this.entryFunction === delegate) {\n                    this._finishCallbackIfDone();\n                }\n            }\n        }\n        onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n            // Let the parent try to handle the error.\n            const result = parentZoneDelegate.handleError(targetZone, error);\n            if (result) {\n                this.failCallback(error);\n                this._alreadyErrored = true;\n            }\n            return false;\n        }\n        onHasTask(delegate, current, target, hasTaskState) {\n            delegate.hasTask(target, hasTaskState);\n            // We should only trigger finishCallback when the target zone is the AsyncTestZone\n            // Consider the following cases.\n            //\n            // const childZone = asyncTestZone.fork({\n            //   name: 'child',\n            //   onHasTask: ...\n            // });\n            //\n            // So we have nested zones declared the onHasTask hook, in this case,\n            // the onHasTask will be triggered twice, and cause the finishCallbackIfDone()\n            // is also be invoked twice. So we need to only trigger the finishCallbackIfDone()\n            // when the current zone is the same as the target zone.\n            if (current !== target) {\n                return;\n            }\n            if (hasTaskState.change == 'microTask') {\n                this._pendingMicroTasks = hasTaskState.microTask;\n                this._finishCallbackIfDone();\n            }\n            else if (hasTaskState.change == 'macroTask') {\n                this._pendingMacroTasks = hasTaskState.macroTask;\n                this._finishCallbackIfDone();\n            }\n        }\n    }\n    AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__('parentUnresolved');\n    // Export the class so that new instances can be created with proper\n    // constructor params.\n    Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n})(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\nZone.__load_patch('asynctest', (global, Zone, api) => {\n    /**\n     * Wraps a test function in an asynchronous test zone. The test will automatically\n     * complete when all asynchronous calls within this zone are done.\n     */\n    Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n        // If we're running using the Jasmine test framework, adapt to call the 'done'\n        // function when asynchronous activity is finished.\n        if (global.jasmine) {\n            // Not using an arrow function to preserve context passed from call site\n            return function (done) {\n                if (!done) {\n                    // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n                    // fake it here and assume sync.\n                    done = function () { };\n                    done.fail = function (e) {\n                        throw e;\n                    };\n                }\n                runInTestZone(fn, this, done, (err) => {\n                    if (typeof err === 'string') {\n                        return done.fail(new Error(err));\n                    }\n                    else {\n                        done.fail(err);\n                    }\n                });\n            };\n        }\n        // Otherwise, return a promise which will resolve when asynchronous activity\n        // is finished. This will be correctly consumed by the Mocha framework with\n        // it('...', async(myFn)); or can be used in a custom framework.\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            return new Promise((finishCallback, failCallback) => {\n                runInTestZone(fn, this, finishCallback, failCallback);\n            });\n        };\n    };\n    function runInTestZone(fn, context, finishCallback, failCallback) {\n        const currentZone = Zone.current;\n        const AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n        if (AsyncTestZoneSpec === undefined) {\n            throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' +\n                'Please make sure that your environment includes zone.js/plugins/async-test');\n        }\n        const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        if (!ProxyZoneSpec) {\n            throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n                'Please make sure that your environment includes zone.js/plugins/proxy');\n        }\n        const proxyZoneSpec = ProxyZoneSpec.get();\n        ProxyZoneSpec.assertPresent();\n        // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n        // If we do it in ProxyZone then we will get to infinite recursion.\n        const proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n        const previousDelegate = proxyZoneSpec.getDelegate();\n        proxyZone.parent.run(() => {\n            const testZoneSpec = new AsyncTestZoneSpec(() => {\n                // Need to restore the original zone.\n                if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                    // Only reset the zone spec if it's\n                    // sill this one. Otherwise, assume\n                    // it's OK.\n                    proxyZoneSpec.setDelegate(previousDelegate);\n                }\n                testZoneSpec.unPatchPromiseForTest();\n                currentZone.run(() => {\n                    finishCallback();\n                });\n            }, (error) => {\n                // Need to restore the original zone.\n                if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                    // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n                    proxyZoneSpec.setDelegate(previousDelegate);\n                }\n                testZoneSpec.unPatchPromiseForTest();\n                currentZone.run(() => {\n                    failCallback(error);\n                });\n            }, 'test');\n            proxyZoneSpec.setDelegate(testZoneSpec);\n            testZoneSpec.patchPromiseForTest();\n        });\n        return Zone.current.runGuarded(fn, context);\n    }\n});\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (global) {\n    const OriginalDate = global.Date;\n    // Since when we compile this file to `es2015`, and if we define\n    // this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n    // there will be an error which is `Cannot assign to read only property 'prototype'`\n    // so we need to use function implementation here.\n    function FakeDate() {\n        if (arguments.length === 0) {\n            const d = new OriginalDate();\n            d.setTime(FakeDate.now());\n            return d;\n        }\n        else {\n            const args = Array.prototype.slice.call(arguments);\n            return new OriginalDate(...args);\n        }\n    }\n    FakeDate.now = function () {\n        const fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n        if (fakeAsyncTestZoneSpec) {\n            return fakeAsyncTestZoneSpec.getFakeSystemTime();\n        }\n        return OriginalDate.now.apply(this, arguments);\n    };\n    FakeDate.UTC = OriginalDate.UTC;\n    FakeDate.parse = OriginalDate.parse;\n    // keep a reference for zone patched timer function\n    const timers = {\n        setTimeout: global.setTimeout,\n        setInterval: global.setInterval,\n        clearTimeout: global.clearTimeout,\n        clearInterval: global.clearInterval\n    };\n    class Scheduler {\n        constructor() {\n            // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n            this._schedulerQueue = [];\n            // Current simulated time in millis.\n            this._currentTickTime = 0;\n            // Current fake system base time in millis.\n            this._currentFakeBaseSystemTime = OriginalDate.now();\n            // track requeuePeriodicTimer\n            this._currentTickRequeuePeriodicEntries = [];\n        }\n        getCurrentTickTime() {\n            return this._currentTickTime;\n        }\n        getFakeSystemTime() {\n            return this._currentFakeBaseSystemTime + this._currentTickTime;\n        }\n        setFakeBaseSystemTime(fakeBaseSystemTime) {\n            this._currentFakeBaseSystemTime = fakeBaseSystemTime;\n        }\n        getRealSystemTime() {\n            return OriginalDate.now();\n        }\n        scheduleFunction(cb, delay, options) {\n            options = Object.assign({\n                args: [],\n                isPeriodic: false,\n                isRequestAnimationFrame: false,\n                id: -1,\n                isRequeuePeriodic: false\n            }, options);\n            let currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n            let endTime = this._currentTickTime + delay;\n            // Insert so that scheduler queue remains sorted by end time.\n            let newEntry = {\n                endTime: endTime,\n                id: currentId,\n                func: cb,\n                args: options.args,\n                delay: delay,\n                isPeriodic: options.isPeriodic,\n                isRequestAnimationFrame: options.isRequestAnimationFrame\n            };\n            if (options.isRequeuePeriodic) {\n                this._currentTickRequeuePeriodicEntries.push(newEntry);\n            }\n            let i = 0;\n            for (; i < this._schedulerQueue.length; i++) {\n                let currentEntry = this._schedulerQueue[i];\n                if (newEntry.endTime < currentEntry.endTime) {\n                    break;\n                }\n            }\n            this._schedulerQueue.splice(i, 0, newEntry);\n            return currentId;\n        }\n        removeScheduledFunctionWithId(id) {\n            for (let i = 0; i < this._schedulerQueue.length; i++) {\n                if (this._schedulerQueue[i].id == id) {\n                    this._schedulerQueue.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        removeAll() {\n            this._schedulerQueue = [];\n        }\n        getTimerCount() {\n            return this._schedulerQueue.length;\n        }\n        tickToNext(step = 1, doTick, tickOptions) {\n            if (this._schedulerQueue.length < step) {\n                return;\n            }\n            // Find the last task currently queued in the scheduler queue and tick\n            // till that time.\n            const startTime = this._currentTickTime;\n            const targetTask = this._schedulerQueue[step - 1];\n            this.tick(targetTask.endTime - startTime, doTick, tickOptions);\n        }\n        tick(millis = 0, doTick, tickOptions) {\n            let finalTime = this._currentTickTime + millis;\n            let lastCurrentTime = 0;\n            tickOptions = Object.assign({ processNewMacroTasksSynchronously: true }, tickOptions);\n            // we need to copy the schedulerQueue so nested timeout\n            // will not be wrongly called in the current tick\n            // https://github.com/angular/angular/issues/33799\n            const schedulerQueue = tickOptions.processNewMacroTasksSynchronously ?\n                this._schedulerQueue :\n                this._schedulerQueue.slice();\n            if (schedulerQueue.length === 0 && doTick) {\n                doTick(millis);\n                return;\n            }\n            while (schedulerQueue.length > 0) {\n                // clear requeueEntries before each loop\n                this._currentTickRequeuePeriodicEntries = [];\n                let current = schedulerQueue[0];\n                if (finalTime < current.endTime) {\n                    // Done processing the queue since it's sorted by endTime.\n                    break;\n                }\n                else {\n                    // Time to run scheduled function. Remove it from the head of queue.\n                    let current = schedulerQueue.shift();\n                    if (!tickOptions.processNewMacroTasksSynchronously) {\n                        const idx = this._schedulerQueue.indexOf(current);\n                        if (idx >= 0) {\n                            this._schedulerQueue.splice(idx, 1);\n                        }\n                    }\n                    lastCurrentTime = this._currentTickTime;\n                    this._currentTickTime = current.endTime;\n                    if (doTick) {\n                        doTick(this._currentTickTime - lastCurrentTime);\n                    }\n                    let retval = current.func.apply(global, current.isRequestAnimationFrame ? [this._currentTickTime] : current.args);\n                    if (!retval) {\n                        // Uncaught exception in the current scheduled function. Stop processing the queue.\n                        break;\n                    }\n                    // check is there any requeue periodic entry is added in\n                    // current loop, if there is, we need to add to current loop\n                    if (!tickOptions.processNewMacroTasksSynchronously) {\n                        this._currentTickRequeuePeriodicEntries.forEach(newEntry => {\n                            let i = 0;\n                            for (; i < schedulerQueue.length; i++) {\n                                const currentEntry = schedulerQueue[i];\n                                if (newEntry.endTime < currentEntry.endTime) {\n                                    break;\n                                }\n                            }\n                            schedulerQueue.splice(i, 0, newEntry);\n                        });\n                    }\n                }\n            }\n            lastCurrentTime = this._currentTickTime;\n            this._currentTickTime = finalTime;\n            if (doTick) {\n                doTick(this._currentTickTime - lastCurrentTime);\n            }\n        }\n        flushOnlyPendingTimers(doTick) {\n            if (this._schedulerQueue.length === 0) {\n                return 0;\n            }\n            // Find the last task currently queued in the scheduler queue and tick\n            // till that time.\n            const startTime = this._currentTickTime;\n            const lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n            this.tick(lastTask.endTime - startTime, doTick, { processNewMacroTasksSynchronously: false });\n            return this._currentTickTime - startTime;\n        }\n        flush(limit = 20, flushPeriodic = false, doTick) {\n            if (flushPeriodic) {\n                return this.flushPeriodic(doTick);\n            }\n            else {\n                return this.flushNonPeriodic(limit, doTick);\n            }\n        }\n        flushPeriodic(doTick) {\n            if (this._schedulerQueue.length === 0) {\n                return 0;\n            }\n            // Find the last task currently queued in the scheduler queue and tick\n            // till that time.\n            const startTime = this._currentTickTime;\n            const lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n            this.tick(lastTask.endTime - startTime, doTick);\n            return this._currentTickTime - startTime;\n        }\n        flushNonPeriodic(limit, doTick) {\n            const startTime = this._currentTickTime;\n            let lastCurrentTime = 0;\n            let count = 0;\n            while (this._schedulerQueue.length > 0) {\n                count++;\n                if (count > limit) {\n                    throw new Error('flush failed after reaching the limit of ' + limit +\n                        ' tasks. Does your code use a polling timeout?');\n                }\n                // flush only non-periodic timers.\n                // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n                if (this._schedulerQueue.filter(task => !task.isPeriodic && !task.isRequestAnimationFrame)\n                    .length === 0) {\n                    break;\n                }\n                const current = this._schedulerQueue.shift();\n                lastCurrentTime = this._currentTickTime;\n                this._currentTickTime = current.endTime;\n                if (doTick) {\n                    // Update any secondary schedulers like Jasmine mock Date.\n                    doTick(this._currentTickTime - lastCurrentTime);\n                }\n                const retval = current.func.apply(global, current.args);\n                if (!retval) {\n                    // Uncaught exception in the current scheduled function. Stop processing the queue.\n                    break;\n                }\n            }\n            return this._currentTickTime - startTime;\n        }\n    }\n    // Next scheduler id.\n    Scheduler.nextId = 1;\n    class FakeAsyncTestZoneSpec {\n        constructor(namePrefix, trackPendingRequestAnimationFrame = false, macroTaskOptions) {\n            this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n            this.macroTaskOptions = macroTaskOptions;\n            this._scheduler = new Scheduler();\n            this._microtasks = [];\n            this._lastError = null;\n            this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n            this.pendingPeriodicTimers = [];\n            this.pendingTimers = [];\n            this.patchDateLocked = false;\n            this.properties = { 'FakeAsyncTestZoneSpec': this };\n            this.name = 'fakeAsyncTestZone for ' + namePrefix;\n            // in case user can't access the construction of FakeAsyncTestSpec\n            // user can also define macroTaskOptions by define a global variable.\n            if (!this.macroTaskOptions) {\n                this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n            }\n        }\n        static assertInZone() {\n            if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n                throw new Error('The code should be running in the fakeAsync zone to call this function');\n            }\n        }\n        _fnAndFlush(fn, completers) {\n            return (...args) => {\n                fn.apply(global, args);\n                if (this._lastError === null) { // Success\n                    if (completers.onSuccess != null) {\n                        completers.onSuccess.apply(global);\n                    }\n                    // Flush microtasks only on success.\n                    this.flushMicrotasks();\n                }\n                else { // Failure\n                    if (completers.onError != null) {\n                        completers.onError.apply(global);\n                    }\n                }\n                // Return true if there were no errors, false otherwise.\n                return this._lastError === null;\n            };\n        }\n        static _removeTimer(timers, id) {\n            let index = timers.indexOf(id);\n            if (index > -1) {\n                timers.splice(index, 1);\n            }\n        }\n        _dequeueTimer(id) {\n            return () => {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n            };\n        }\n        _requeuePeriodicTimer(fn, interval, args, id) {\n            return () => {\n                // Requeue the timer callback if it's not been canceled.\n                if (this.pendingPeriodicTimers.indexOf(id) !== -1) {\n                    this._scheduler.scheduleFunction(fn, interval, { args, isPeriodic: true, id, isRequeuePeriodic: true });\n                }\n            };\n        }\n        _dequeuePeriodicTimer(id) {\n            return () => {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n            };\n        }\n        _setTimeout(fn, delay, args, isTimer = true) {\n            let removeTimerFn = this._dequeueTimer(Scheduler.nextId);\n            // Queue the callback and dequeue the timer on success and error.\n            let cb = this._fnAndFlush(fn, { onSuccess: removeTimerFn, onError: removeTimerFn });\n            let id = this._scheduler.scheduleFunction(cb, delay, { args, isRequestAnimationFrame: !isTimer });\n            if (isTimer) {\n                this.pendingTimers.push(id);\n            }\n            return id;\n        }\n        _clearTimeout(id) {\n            FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n            this._scheduler.removeScheduledFunctionWithId(id);\n        }\n        _setInterval(fn, interval, args) {\n            let id = Scheduler.nextId;\n            let completers = { onSuccess: null, onError: this._dequeuePeriodicTimer(id) };\n            let cb = this._fnAndFlush(fn, completers);\n            // Use the callback created above to requeue on success.\n            completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id);\n            // Queue the callback and dequeue the periodic timer only on error.\n            this._scheduler.scheduleFunction(cb, interval, { args, isPeriodic: true });\n            this.pendingPeriodicTimers.push(id);\n            return id;\n        }\n        _clearInterval(id) {\n            FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n            this._scheduler.removeScheduledFunctionWithId(id);\n        }\n        _resetLastErrorAndThrow() {\n            let error = this._lastError || this._uncaughtPromiseErrors[0];\n            this._uncaughtPromiseErrors.length = 0;\n            this._lastError = null;\n            throw error;\n        }\n        getCurrentTickTime() {\n            return this._scheduler.getCurrentTickTime();\n        }\n        getFakeSystemTime() {\n            return this._scheduler.getFakeSystemTime();\n        }\n        setFakeBaseSystemTime(realTime) {\n            this._scheduler.setFakeBaseSystemTime(realTime);\n        }\n        getRealSystemTime() {\n            return this._scheduler.getRealSystemTime();\n        }\n        static patchDate() {\n            if (!!global[Zone.__symbol__('disableDatePatching')]) {\n                // we don't want to patch global Date\n                // because in some case, global Date\n                // is already being patched, we need to provide\n                // an option to let user still use their\n                // own version of Date.\n                return;\n            }\n            if (global['Date'] === FakeDate) {\n                // already patched\n                return;\n            }\n            global['Date'] = FakeDate;\n            FakeDate.prototype = OriginalDate.prototype;\n            // try check and reset timers\n            // because jasmine.clock().install() may\n            // have replaced the global timer\n            FakeAsyncTestZoneSpec.checkTimerPatch();\n        }\n        static resetDate() {\n            if (global['Date'] === FakeDate) {\n                global['Date'] = OriginalDate;\n            }\n        }\n        static checkTimerPatch() {\n            if (global.setTimeout !== timers.setTimeout) {\n                global.setTimeout = timers.setTimeout;\n                global.clearTimeout = timers.clearTimeout;\n            }\n            if (global.setInterval !== timers.setInterval) {\n                global.setInterval = timers.setInterval;\n                global.clearInterval = timers.clearInterval;\n            }\n        }\n        lockDatePatch() {\n            this.patchDateLocked = true;\n            FakeAsyncTestZoneSpec.patchDate();\n        }\n        unlockDatePatch() {\n            this.patchDateLocked = false;\n            FakeAsyncTestZoneSpec.resetDate();\n        }\n        tickToNext(steps = 1, doTick, tickOptions = { processNewMacroTasksSynchronously: true }) {\n            if (steps <= 0) {\n                return;\n            }\n            FakeAsyncTestZoneSpec.assertInZone();\n            this.flushMicrotasks();\n            this._scheduler.tickToNext(steps, doTick, tickOptions);\n            if (this._lastError !== null) {\n                this._resetLastErrorAndThrow();\n            }\n        }\n        tick(millis = 0, doTick, tickOptions = { processNewMacroTasksSynchronously: true }) {\n            FakeAsyncTestZoneSpec.assertInZone();\n            this.flushMicrotasks();\n            this._scheduler.tick(millis, doTick, tickOptions);\n            if (this._lastError !== null) {\n                this._resetLastErrorAndThrow();\n            }\n        }\n        flushMicrotasks() {\n            FakeAsyncTestZoneSpec.assertInZone();\n            const flushErrors = () => {\n                if (this._lastError !== null || this._uncaughtPromiseErrors.length) {\n                    // If there is an error stop processing the microtask queue and rethrow the error.\n                    this._resetLastErrorAndThrow();\n                }\n            };\n            while (this._microtasks.length > 0) {\n                let microtask = this._microtasks.shift();\n                microtask.func.apply(microtask.target, microtask.args);\n            }\n            flushErrors();\n        }\n        flush(limit, flushPeriodic, doTick) {\n            FakeAsyncTestZoneSpec.assertInZone();\n            this.flushMicrotasks();\n            const elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n            if (this._lastError !== null) {\n                this._resetLastErrorAndThrow();\n            }\n            return elapsed;\n        }\n        flushOnlyPendingTimers(doTick) {\n            FakeAsyncTestZoneSpec.assertInZone();\n            this.flushMicrotasks();\n            const elapsed = this._scheduler.flushOnlyPendingTimers(doTick);\n            if (this._lastError !== null) {\n                this._resetLastErrorAndThrow();\n            }\n            return elapsed;\n        }\n        removeAllTimers() {\n            FakeAsyncTestZoneSpec.assertInZone();\n            this._scheduler.removeAll();\n            this.pendingPeriodicTimers = [];\n            this.pendingTimers = [];\n        }\n        getTimerCount() {\n            return this._scheduler.getTimerCount() + this._microtasks.length;\n        }\n        onScheduleTask(delegate, current, target, task) {\n            switch (task.type) {\n                case 'microTask':\n                    let args = task.data && task.data.args;\n                    // should pass additional arguments to callback if have any\n                    // currently we know process.nextTick will have such additional\n                    // arguments\n                    let additionalArgs;\n                    if (args) {\n                        let callbackIndex = task.data.cbIdx;\n                        if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                            additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n                        }\n                    }\n                    this._microtasks.push({\n                        func: task.invoke,\n                        args: additionalArgs,\n                        target: task.data && task.data.target\n                    });\n                    break;\n                case 'macroTask':\n                    switch (task.source) {\n                        case 'setTimeout':\n                            task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                            break;\n                        case 'setImmediate':\n                            task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                            break;\n                        case 'setInterval':\n                            task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                            break;\n                        case 'XMLHttpRequest.send':\n                            throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' +\n                                task.data['url']);\n                        case 'requestAnimationFrame':\n                        case 'webkitRequestAnimationFrame':\n                        case 'mozRequestAnimationFrame':\n                            // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                            // (60 frames per second)\n                            task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                            break;\n                        default:\n                            // user can define which macroTask they want to support by passing\n                            // macroTaskOptions\n                            const macroTaskOption = this.findMacroTaskOption(task);\n                            if (macroTaskOption) {\n                                const args = task.data && task.data['args'];\n                                const delay = args && args.length > 1 ? args[1] : 0;\n                                let callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args;\n                                if (!!macroTaskOption.isPeriodic) {\n                                    // periodic macroTask, use setInterval to simulate\n                                    task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                                    task.data.isPeriodic = true;\n                                }\n                                else {\n                                    // not periodic, use setTimeout to simulate\n                                    task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                                }\n                                break;\n                            }\n                            throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n                    }\n                    break;\n                case 'eventTask':\n                    task = delegate.scheduleTask(target, task);\n                    break;\n            }\n            return task;\n        }\n        onCancelTask(delegate, current, target, task) {\n            switch (task.source) {\n                case 'setTimeout':\n                case 'requestAnimationFrame':\n                case 'webkitRequestAnimationFrame':\n                case 'mozRequestAnimationFrame':\n                    return this._clearTimeout(task.data['handleId']);\n                case 'setInterval':\n                    return this._clearInterval(task.data['handleId']);\n                default:\n                    // user can define which macroTask they want to support by passing\n                    // macroTaskOptions\n                    const macroTaskOption = this.findMacroTaskOption(task);\n                    if (macroTaskOption) {\n                        const handleId = task.data['handleId'];\n                        return macroTaskOption.isPeriodic ? this._clearInterval(handleId) :\n                            this._clearTimeout(handleId);\n                    }\n                    return delegate.cancelTask(target, task);\n            }\n        }\n        onInvoke(delegate, current, target, callback, applyThis, applyArgs, source) {\n            try {\n                FakeAsyncTestZoneSpec.patchDate();\n                return delegate.invoke(target, callback, applyThis, applyArgs, source);\n            }\n            finally {\n                if (!this.patchDateLocked) {\n                    FakeAsyncTestZoneSpec.resetDate();\n                }\n            }\n        }\n        findMacroTaskOption(task) {\n            if (!this.macroTaskOptions) {\n                return null;\n            }\n            for (let i = 0; i < this.macroTaskOptions.length; i++) {\n                const macroTaskOption = this.macroTaskOptions[i];\n                if (macroTaskOption.source === task.source) {\n                    return macroTaskOption;\n                }\n            }\n            return null;\n        }\n        onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n            this._lastError = error;\n            return false; // Don't propagate error to parent zone.\n        }\n    }\n    // Export the class so that new instances can be created with proper\n    // constructor params.\n    Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n})(typeof window === 'object' && window || typeof self === 'object' && self || global);\nZone.__load_patch('fakeasync', (global, Zone, api) => {\n    const FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n    function getProxyZoneSpec() {\n        return Zone && Zone['ProxyZoneSpec'];\n    }\n    let _fakeAsyncTestZoneSpec = null;\n    /**\n     * Clears out the shared fake async zone for a test.\n     * To be called in a global `beforeEach`.\n     *\n     * @experimental\n     */\n    function resetFakeAsyncZone() {\n        if (_fakeAsyncTestZoneSpec) {\n            _fakeAsyncTestZoneSpec.unlockDatePatch();\n        }\n        _fakeAsyncTestZoneSpec = null;\n        // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n        getProxyZoneSpec() && getProxyZoneSpec().assertPresent().resetDelegate();\n    }\n    /**\n     * Wraps a function to be executed in the fakeAsync zone:\n     * - microtasks are manually executed by calling `flushMicrotasks()`,\n     * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n     *\n     * If there are any pending timers at the end of the function, an exception will be thrown.\n     *\n     * Can be used to wrap inject() calls.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @param fn\n     * @returns The function wrapped to be executed in the fakeAsync zone\n     *\n     * @experimental\n     */\n    function fakeAsync(fn) {\n        // Not using an arrow function to preserve context passed from call site\n        const fakeAsyncFn = function (...args) {\n            const ProxyZoneSpec = getProxyZoneSpec();\n            if (!ProxyZoneSpec) {\n                throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n                    'Please make sure that your environment includes zone.js/plugins/proxy');\n            }\n            const proxyZoneSpec = ProxyZoneSpec.assertPresent();\n            if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n                throw new Error('fakeAsync() calls can not be nested');\n            }\n            try {\n                // in case jasmine.clock init a fakeAsyncTestZoneSpec\n                if (!_fakeAsyncTestZoneSpec) {\n                    if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n                        throw new Error('fakeAsync() calls can not be nested');\n                    }\n                    _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n                }\n                let res;\n                const lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n                proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n                _fakeAsyncTestZoneSpec.lockDatePatch();\n                try {\n                    res = fn.apply(this, args);\n                    flushMicrotasks();\n                }\n                finally {\n                    proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n                }\n                if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n                    throw new Error(`${_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length} ` +\n                        `periodic timer(s) still in the queue.`);\n                }\n                if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n                    throw new Error(`${_fakeAsyncTestZoneSpec.pendingTimers.length} timer(s) still in the queue.`);\n                }\n                return res;\n            }\n            finally {\n                resetFakeAsyncZone();\n            }\n        };\n        fakeAsyncFn.isFakeAsync = true;\n        return fakeAsyncFn;\n    }\n    function _getFakeAsyncZoneSpec() {\n        if (_fakeAsyncTestZoneSpec == null) {\n            _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n            if (_fakeAsyncTestZoneSpec == null) {\n                throw new Error('The code should be running in the fakeAsync zone to call this function');\n            }\n        }\n        return _fakeAsyncTestZoneSpec;\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n     *\n     * The microtasks queue is drained at the very start of this function and after any timer callback\n     * has been executed.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @experimental\n     */\n    function tick(millis = 0, ignoreNestedTimeout = false) {\n        _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n     * draining the macrotask queue until it is empty. The returned value is the milliseconds\n     * of time that would have been elapsed.\n     *\n     * @param maxTurns\n     * @returns The simulated time elapsed, in millis.\n     *\n     * @experimental\n     */\n    function flush(maxTurns) {\n        return _getFakeAsyncZoneSpec().flush(maxTurns);\n    }\n    /**\n     * Discard all remaining periodic tasks.\n     *\n     * @experimental\n     */\n    function discardPeriodicTasks() {\n        const zoneSpec = _getFakeAsyncZoneSpec();\n        zoneSpec.pendingPeriodicTimers;\n        zoneSpec.pendingPeriodicTimers.length = 0;\n    }\n    /**\n     * Flush any pending microtasks.\n     *\n     * @experimental\n     */\n    function flushMicrotasks() {\n        _getFakeAsyncZoneSpec().flushMicrotasks();\n    }\n    Zone[api.symbol('fakeAsyncTest')] =\n        { resetFakeAsyncZone, flushMicrotasks, discardPeriodicTasks, tick, flush, fakeAsync };\n}, true);\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Promise for async/fakeAsync zoneSpec test\n * can support async operation which not supported by zone.js\n * such as\n * it ('test jsonp in AsyncZone', async() => {\n *   new Promise(res => {\n *     jsonp(url, (data) => {\n *       // success callback\n *       res(data);\n *     });\n *   }).then((jsonpResult) => {\n *     // get jsonp result.\n *\n *     // user will expect AsyncZoneSpec wait for\n *     // then, but because jsonp is not zone aware\n *     // AsyncZone will finish before then is called.\n *   });\n * });\n */\nZone.__load_patch('promisefortest', (global, Zone, api) => {\n    const symbolState = api.symbol('state');\n    const UNRESOLVED = null;\n    const symbolParentUnresolved = api.symbol('parentUnresolved');\n    // patch Promise.prototype.then to keep an internal\n    // number for tracking unresolved chained promise\n    // we will decrease this number when the parent promise\n    // being resolved/rejected and chained promise was\n    // scheduled as a microTask.\n    // so we can know such kind of chained promise still\n    // not resolved in AsyncTestZone\n    Promise[api.symbol('patchPromiseForTest')] = function patchPromiseForTest() {\n        let oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n        if (oriThen) {\n            return;\n        }\n        oriThen = Promise[Zone.__symbol__('ZonePromiseThen')] = Promise.prototype.then;\n        Promise.prototype.then = function () {\n            const chained = oriThen.apply(this, arguments);\n            if (this[symbolState] === UNRESOLVED) {\n                // parent promise is unresolved.\n                const asyncTestZoneSpec = Zone.current.get('AsyncTestZoneSpec');\n                if (asyncTestZoneSpec) {\n                    asyncTestZoneSpec.unresolvedChainedPromiseCount++;\n                    chained[symbolParentUnresolved] = true;\n                }\n            }\n            return chained;\n        };\n    };\n    Promise[api.symbol('unPatchPromiseForTest')] = function unpatchPromiseForTest() {\n        // restore origin then\n        const oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n        if (oriThen) {\n            Promise.prototype.then = oriThen;\n            Promise[Zone.__symbol__('ZonePromiseThen')] = undefined;\n        }\n    };\n});\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA,MAAMA,OAAO,GAAG,IAAhB;AACA,MAAMC,aAAa,GAAG,EAAtB;AACA,MAAMC,aAAa,GAAG,mBAAtB;AACA,MAAMC,SAAS,GAAG,qBAAlB;AACA,MAAMC,OAAO,GAAG,aAAhB;AACA,IAAIC,WAAW,GAAGD,OAAO,GAAG,WAA5B;;AACA,MAAME,cAAN,CAAqB;EACjBC,WAAW,GAAG;IACV,KAAKC,KAAL,GAAaC,aAAa,EAA1B;IACA,KAAKC,SAAL,GAAiB,IAAIC,IAAJ,EAAjB;EACH;;AAJgB;;AAMrB,SAASC,8BAAT,GAA0C;EACtC,OAAO,IAAIC,KAAJ,CAAUV,SAAV,CAAP;AACH;;AACD,SAASW,4BAAT,GAAwC;EACpC,IAAI;IACA,MAAMF,8BAA8B,EAApC;EACH,CAFD,CAGA,OAAOG,GAAP,EAAY;IACR,OAAOA,GAAP;EACH;AACJ,C,CACD;AACA;;;AACA,MAAMP,KAAK,GAAGI,8BAA8B,EAA5C;AACA,MAAMI,WAAW,GAAGF,4BAA4B,EAAhD;AACA,MAAML,aAAa,GAAGD,KAAK,CAACS,KAAN,GAClBL,8BADkB,GAEjBI,WAAW,CAACC,KAAZ,GAAoBH,4BAApB,GAAmDF,8BAFxD;;AAGA,SAASM,SAAT,CAAmBV,KAAnB,EAA0B;EACtB,OAAOA,KAAK,CAACS,KAAN,GAAcT,KAAK,CAACS,KAAN,CAAYE,KAAZ,CAAkBnB,OAAlB,CAAd,GAA2C,EAAlD;AACH;;AACD,SAASoB,aAAT,CAAuBC,KAAvB,EAA8Bb,KAA9B,EAAqC;EACjC,IAAIc,KAAK,GAAGJ,SAAS,CAACV,KAAD,CAArB;;EACA,KAAK,IAAIe,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;IACnC,MAAME,KAAK,GAAGH,KAAK,CAACC,CAAD,CAAnB,CADmC,CAEnC;;IACA,IAAI,CAACtB,aAAa,CAACyB,cAAd,CAA6BD,KAA7B,CAAL,EAA0C;MACtCJ,KAAK,CAACM,IAAN,CAAWL,KAAK,CAACC,CAAD,CAAhB;IACH;EACJ;AACJ;;AACD,SAASK,oBAAT,CAA8BC,MAA9B,EAAsCZ,KAAtC,EAA6C;EACzC,MAAMa,SAAS,GAAG,CAACb,KAAK,GAAGA,KAAK,CAACc,IAAN,EAAH,GAAkB,EAAxB,CAAlB;;EACA,IAAIF,MAAJ,EAAY;IACR,IAAInB,SAAS,GAAG,IAAIC,IAAJ,GAAWqB,OAAX,EAAhB;;IACA,KAAK,IAAIT,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,MAAM,CAACL,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;MACpC,MAAMU,WAAW,GAAGJ,MAAM,CAACN,CAAD,CAA1B;MACA,MAAMW,QAAQ,GAAGD,WAAW,CAACvB,SAA7B;MACA,IAAIyB,SAAS,GAAI,+BAA8BzB,SAAS,GAAGwB,QAAQ,CAACF,OAAT,EAAmB,YAAWE,QAAS,EAAlG;MACAC,SAAS,GAAGA,SAAS,CAACC,OAAV,CAAkB,UAAlB,EAA8B,GAA9B,CAAZ;MACAN,SAAS,CAACH,IAAV,CAAetB,WAAW,CAAC+B,OAAZ,CAAoBhC,OAApB,EAA6B+B,SAA7B,CAAf;MACAf,aAAa,CAACU,SAAD,EAAYG,WAAW,CAACzB,KAAxB,CAAb;MACAE,SAAS,GAAGwB,QAAQ,CAACF,OAAT,EAAZ;IACH;EACJ;;EACD,OAAOF,SAAS,CAACO,IAAV,CAAerC,OAAf,CAAP;AACH,C,CACD;AACA;AACA;AACA;;;AACA,SAASsC,kBAAT,GAA8B;EAC1B;EACA;EACA,OAAOzB,KAAK,CAAC0B,eAAN,GAAwB,CAA/B;AACH;;AACDC,IAAI,CAAC,wBAAD,CAAJ,GAAiC;EAC7BC,IAAI,EAAE,kBADuB;EAE7BC,mBAAmB,EAAE,EAFQ;EAG7B;EACA;EACAC,iBAAiB,EAAE,UAAUnC,KAAV,EAAiB;IAChC,IAAI,CAACA,KAAL,EAAY;MACR,OAAOoC,SAAP;IACH;;IACD,MAAMtB,KAAK,GAAGd,KAAK,CAACgC,IAAI,CAACK,UAAL,CAAgB,kBAAhB,CAAD,CAAnB;;IACA,IAAI,CAACvB,KAAL,EAAY;MACR,OAAOd,KAAK,CAACS,KAAb;IACH;;IACD,OAAOW,oBAAoB,CAACN,KAAD,EAAQd,KAAK,CAACS,KAAd,CAA3B;EACH,CAd4B;EAe7B6B,cAAc,EAAE,UAAUC,kBAAV,EAA8BC,WAA9B,EAA2CC,UAA3C,EAAuDC,IAAvD,EAA6D;IACzE,IAAIZ,kBAAkB,EAAtB,EAA0B;MACtB,MAAMa,WAAW,GAAGX,IAAI,CAACW,WAAzB;MACA,IAAI7B,KAAK,GAAG6B,WAAW,IAAIA,WAAW,CAACC,IAA3B,IAAmCD,WAAW,CAACC,IAAZ,CAAiBlD,aAAjB,CAAnC,IAAsE,EAAlF;MACAoB,KAAK,GAAG,CAAC,IAAIhB,cAAJ,EAAD,EAAuB+C,MAAvB,CAA8B/B,KAA9B,CAAR;;MACA,IAAIA,KAAK,CAACE,MAAN,GAAe,KAAKkB,mBAAxB,EAA6C;QACzCpB,KAAK,CAACE,MAAN,GAAe,KAAKkB,mBAApB;MACH;;MACD,IAAI,CAACQ,IAAI,CAACE,IAAV,EACIF,IAAI,CAACE,IAAL,GAAY,EAAZ;;MACJ,IAAIF,IAAI,CAACI,IAAL,KAAc,WAAlB,EAA+B;QAC3B;QACA;QACA;QACA;QACA;QACAJ,IAAI,CAACE,IAAL,GAAYG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBN,IAAI,CAACE,IAAvB,CAAZ;MACH;;MACDF,IAAI,CAACE,IAAL,CAAUlD,aAAV,IAA2BoB,KAA3B;IACH;;IACD,OAAOyB,kBAAkB,CAACU,YAAnB,CAAgCR,UAAhC,EAA4CC,IAA5C,CAAP;EACH,CApC4B;EAqC7BQ,aAAa,EAAE,UAAUX,kBAAV,EAA8BC,WAA9B,EAA2CC,UAA3C,EAAuDzC,KAAvD,EAA8D;IACzE,IAAI8B,kBAAkB,EAAtB,EAA0B;MACtB,MAAMqB,UAAU,GAAGnB,IAAI,CAACW,WAAL,IAAoB3C,KAAK,CAAC0C,IAA7C;;MACA,IAAI1C,KAAK,YAAYK,KAAjB,IAA0B8C,UAA9B,EAA0C;QACtC,MAAMC,SAAS,GAAGhC,oBAAoB,CAAC+B,UAAU,CAACP,IAAX,IAAmBO,UAAU,CAACP,IAAX,CAAgBlD,aAAhB,CAApB,EAAoDM,KAAK,CAACS,KAA1D,CAAtC;;QACA,IAAI;UACAT,KAAK,CAACS,KAAN,GAAcT,KAAK,CAACoD,SAAN,GAAkBA,SAAhC;QACH,CAFD,CAGA,OAAO7C,GAAP,EAAY,CACX;MACJ;IACJ;;IACD,OAAOgC,kBAAkB,CAACc,WAAnB,CAA+BZ,UAA/B,EAA2CzC,KAA3C,CAAP;EACH;AAlD4B,CAAjC;;AAoDA,SAASsD,kBAAT,CAA4BC,WAA5B,EAAyCC,KAAzC,EAAgD;EAC5C,IAAIA,KAAK,GAAG,CAAZ,EAAe;IACXD,WAAW,CAACpC,IAAZ,CAAiBT,SAAS,CAAE,IAAIZ,cAAJ,EAAD,CAAuBE,KAAxB,CAA1B;IACAsD,kBAAkB,CAACC,WAAD,EAAcC,KAAK,GAAG,CAAtB,CAAlB;EACH;AACJ;;AACD,SAASC,mBAAT,GAA+B;EAC3B,IAAI,CAAC3B,kBAAkB,EAAvB,EAA2B;IACvB;EACH;;EACD,MAAMT,MAAM,GAAG,EAAf;EACAiC,kBAAkB,CAACjC,MAAD,EAAS,CAAT,CAAlB;EACA,MAAMqC,OAAO,GAAGrC,MAAM,CAAC,CAAD,CAAtB;EACA,MAAMsC,OAAO,GAAGtC,MAAM,CAAC,CAAD,CAAtB;;EACA,KAAK,IAAIN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2C,OAAO,CAAC1C,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;IACrC,MAAM6C,MAAM,GAAGF,OAAO,CAAC3C,CAAD,CAAtB;;IACA,IAAI6C,MAAM,CAACC,OAAP,CAAelE,SAAf,KAA6B,CAAC,CAAlC,EAAqC;MACjC,IAAImE,KAAK,GAAGF,MAAM,CAACE,KAAP,CAAa,WAAb,CAAZ;;MACA,IAAIA,KAAJ,EAAW;QACPjE,WAAW,GAAGiE,KAAK,CAAC,CAAD,CAAL,GAAWlE,OAAX,GAAqB,qBAAnC;QACA;MACH;IACJ;EACJ;;EACD,KAAK,IAAImB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2C,OAAO,CAAC1C,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;IACrC,MAAM6C,MAAM,GAAGF,OAAO,CAAC3C,CAAD,CAAtB;IACA,MAAMgD,MAAM,GAAGJ,OAAO,CAAC5C,CAAD,CAAtB;;IACA,IAAI6C,MAAM,KAAKG,MAAf,EAAuB;MACnBtE,aAAa,CAACmE,MAAD,CAAb,GAAwB,IAAxB;IACH,CAFD,MAGK;MACD;IACH;EACJ;AACJ;;AACDH,mBAAmB;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMO,aAAN,CAAoB;EAChBjE,WAAW,CAACkE,mBAAmB,GAAG,IAAvB,EAA6B;IACpC,KAAKA,mBAAL,GAA2BA,mBAA3B;IACA,KAAKhC,IAAL,GAAY,WAAZ;IACA,KAAKiC,aAAL,GAAqB,IAArB;IACA,KAAKC,UAAL,GAAkB;MAAE,iBAAiB;IAAnB,CAAlB;IACA,KAAKC,YAAL,GAAoB,IAApB;IACA,KAAKC,aAAL,GAAqB,IAArB;IACA,KAAKC,sBAAL,GAA8B,KAA9B;IACA,KAAKC,KAAL,GAAa,EAAb;IACA,KAAKC,WAAL,CAAiBP,mBAAjB;EACH;;EACS,OAAHQ,GAAG,GAAG;IACT,OAAOzC,IAAI,CAAC0C,OAAL,CAAaD,GAAb,CAAiB,eAAjB,CAAP;EACH;;EACc,OAARE,QAAQ,GAAG;IACd,OAAOX,aAAa,CAACS,GAAd,cAA+BT,aAAtC;EACH;;EACmB,OAAbY,aAAa,GAAG;IACnB,IAAI,CAACZ,aAAa,CAACW,QAAd,EAAL,EAA+B;MAC3B,MAAM,IAAItE,KAAJ,CAAW,8DAAX,CAAN;IACH;;IACD,OAAO2D,aAAa,CAACS,GAAd,EAAP;EACH;;EACDD,WAAW,CAACK,YAAD,EAAe;IACtB,MAAMC,aAAa,GAAG,KAAKZ,aAAL,KAAuBW,YAA7C;IACA,KAAKX,aAAL,GAAqBW,YAArB;IACA,KAAKT,YAAL,IAAqB,KAAKA,YAAL,CAAkBW,OAAlB,CAA2BC,GAAD,IAAS,OAAO,KAAKb,UAAL,CAAgBa,GAAhB,CAA1C,CAArB;IACA,KAAKZ,YAAL,GAAoB,IAApB;;IACA,IAAIS,YAAY,IAAIA,YAAY,CAACV,UAAjC,EAA6C;MACzC,KAAKC,YAAL,GAAoBrB,MAAM,CAACkC,IAAP,CAAYJ,YAAY,CAACV,UAAzB,CAApB;MACA,KAAKC,YAAL,CAAkBW,OAAlB,CAA2BG,CAAD,IAAO,KAAKf,UAAL,CAAgBe,CAAhB,IAAqBL,YAAY,CAACV,UAAb,CAAwBe,CAAxB,CAAtD;IACH,CARqB,CAStB;;;IACA,IAAIJ,aAAa,IAAI,KAAKT,aAAtB,KACC,KAAKA,aAAL,CAAmBc,SAAnB,IAAgC,KAAKd,aAAL,CAAmBe,SADpD,CAAJ,EACoE;MAChE,KAAKd,sBAAL,GAA8B,IAA9B;IACH;EACJ;;EACDe,WAAW,GAAG;IACV,OAAO,KAAKnB,aAAZ;EACH;;EACDoB,aAAa,GAAG;IACZ,KAAKD,WAAL;IACA,KAAKb,WAAL,CAAiB,KAAKP,mBAAtB;EACH;;EACDsB,iBAAiB,CAAChD,kBAAD,EAAqBC,WAArB,EAAkCC,UAAlC,EAA8C;IAC3D,IAAI,KAAK6B,sBAAL,IAA+B,KAAKD,aAAxC,EAAuD;MACnD;MACA;MACA,KAAKC,sBAAL,GAA8B,KAA9B;MACA,KAAKkB,SAAL,CAAejD,kBAAf,EAAmCC,WAAnC,EAAgDC,UAAhD,EAA4D,KAAK4B,aAAjE;IACH;EACJ;;EACDoB,eAAe,CAAC/C,IAAD,EAAO;IAClB,IAAI,CAAC,KAAK6B,KAAV,EAAiB;MACb;IACH;;IACD,KAAK,IAAIxD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKwD,KAAL,CAAWvD,MAA/B,EAAuCD,CAAC,EAAxC,EAA4C;MACxC,IAAI,KAAKwD,KAAL,CAAWxD,CAAX,MAAkB2B,IAAtB,EAA4B;QACxB,KAAK6B,KAAL,CAAWmB,MAAX,CAAkB3E,CAAlB,EAAqB,CAArB;QACA;MACH;IACJ;EACJ;;EACD4E,2BAA2B,GAAG;IAC1B,IAAI,KAAKpB,KAAL,CAAWvD,MAAX,KAAsB,CAA1B,EAA6B;MACzB,OAAO,EAAP;IACH;;IACD,MAAM4E,QAAQ,GAAG,KAAKrB,KAAL,CAAWsB,GAAX,CAAgBnD,IAAD,IAAU;MACtC,MAAMoD,QAAQ,GAAGpD,IAAI,CAACE,IAAL,IACbG,MAAM,CAACkC,IAAP,CAAYvC,IAAI,CAACE,IAAjB,EACKiD,GADL,CACUb,GAAD,IAAS;QACd,OAAOA,GAAG,GAAG,GAAN,GAAYtC,IAAI,CAACE,IAAL,CAAUoC,GAAV,CAAnB;MACH,CAHD,EAIKnD,IAJL,CAIU,GAJV,CADJ;MAMA,OAAQ,SAAQa,IAAI,CAACI,IAAK,aAAYJ,IAAI,CAACqD,MAAO,YAAWD,QAAS,GAAtE;IACH,CARgB,CAAjB;IASA,MAAME,gBAAgB,GAAG,iCAAiCJ,QAAjC,GAA4C,GAArE,CAb0B,CAc1B;;IACA,KAAKrB,KAAL,GAAa,EAAb;IACA,OAAOyB,gBAAP;EACH;;EACDC,MAAM,CAAC1D,kBAAD,EAAqBC,WAArB,EAAkCC,UAAlC,EAA8CyD,QAA9C,EAAwD;IAC1D,IAAI,KAAKhC,aAAL,IAAsB,KAAKA,aAAL,CAAmB+B,MAA7C,EAAqD;MACjD,OAAO,KAAK/B,aAAL,CAAmB+B,MAAnB,CAA0B1D,kBAA1B,EAA8CC,WAA9C,EAA2DC,UAA3D,EAAuEyD,QAAvE,CAAP;IACH,CAFD,MAGK;MACD,OAAO3D,kBAAkB,CAAC4D,IAAnB,CAAwB1D,UAAxB,EAAoCyD,QAApC,CAAP;IACH;EACJ;;EACDE,WAAW,CAAC7D,kBAAD,EAAqBC,WAArB,EAAkCC,UAAlC,EAA8C4D,QAA9C,EAAwDN,MAAxD,EAAgE;IACvE,IAAI,KAAK7B,aAAL,IAAsB,KAAKA,aAAL,CAAmBkC,WAA7C,EAA0D;MACtD,OAAO,KAAKlC,aAAL,CAAmBkC,WAAnB,CAA+B7D,kBAA/B,EAAmDC,WAAnD,EAAgEC,UAAhE,EAA4E4D,QAA5E,EAAsFN,MAAtF,CAAP;IACH,CAFD,MAGK;MACD,OAAOxD,kBAAkB,CAAC+D,SAAnB,CAA6B7D,UAA7B,EAAyC4D,QAAzC,EAAmDN,MAAnD,CAAP;IACH;EACJ;;EACDQ,QAAQ,CAAChE,kBAAD,EAAqBC,WAArB,EAAkCC,UAAlC,EAA8C4D,QAA9C,EAAwDG,SAAxD,EAAmEC,SAAnE,EAA8EV,MAA9E,EAAsF;IAC1F,KAAKR,iBAAL,CAAuBhD,kBAAvB,EAA2CC,WAA3C,EAAwDC,UAAxD;;IACA,IAAI,KAAKyB,aAAL,IAAsB,KAAKA,aAAL,CAAmBqC,QAA7C,EAAuD;MACnD,OAAO,KAAKrC,aAAL,CAAmBqC,QAAnB,CAA4BhE,kBAA5B,EAAgDC,WAAhD,EAA6DC,UAA7D,EAAyE4D,QAAzE,EAAmFG,SAAnF,EAA8FC,SAA9F,EAAyGV,MAAzG,CAAP;IACH,CAFD,MAGK;MACD,OAAOxD,kBAAkB,CAACmE,MAAnB,CAA0BjE,UAA1B,EAAsC4D,QAAtC,EAAgDG,SAAhD,EAA2DC,SAA3D,EAAsEV,MAAtE,CAAP;IACH;EACJ;;EACD7C,aAAa,CAACX,kBAAD,EAAqBC,WAArB,EAAkCC,UAAlC,EAA8CzC,KAA9C,EAAqD;IAC9D,IAAI,KAAKkE,aAAL,IAAsB,KAAKA,aAAL,CAAmBhB,aAA7C,EAA4D;MACxD,OAAO,KAAKgB,aAAL,CAAmBhB,aAAnB,CAAiCX,kBAAjC,EAAqDC,WAArD,EAAkEC,UAAlE,EAA8EzC,KAA9E,CAAP;IACH,CAFD,MAGK;MACD,OAAOuC,kBAAkB,CAACc,WAAnB,CAA+BZ,UAA/B,EAA2CzC,KAA3C,CAAP;IACH;EACJ;;EACDsC,cAAc,CAACC,kBAAD,EAAqBC,WAArB,EAAkCC,UAAlC,EAA8CC,IAA9C,EAAoD;IAC9D,IAAIA,IAAI,CAACI,IAAL,KAAc,WAAlB,EAA+B;MAC3B,KAAKyB,KAAL,CAAWpD,IAAX,CAAgBuB,IAAhB;IACH;;IACD,IAAI,KAAKwB,aAAL,IAAsB,KAAKA,aAAL,CAAmB5B,cAA7C,EAA6D;MACzD,OAAO,KAAK4B,aAAL,CAAmB5B,cAAnB,CAAkCC,kBAAlC,EAAsDC,WAAtD,EAAmEC,UAAnE,EAA+EC,IAA/E,CAAP;IACH,CAFD,MAGK;MACD,OAAOH,kBAAkB,CAACU,YAAnB,CAAgCR,UAAhC,EAA4CC,IAA5C,CAAP;IACH;EACJ;;EACDiE,YAAY,CAACpE,kBAAD,EAAqBC,WAArB,EAAkCC,UAAlC,EAA8CC,IAA9C,EAAoD8D,SAApD,EAA+DC,SAA/D,EAA0E;IAClF,IAAI/D,IAAI,CAACI,IAAL,KAAc,WAAlB,EAA+B;MAC3B,KAAK2C,eAAL,CAAqB/C,IAArB;IACH;;IACD,KAAK6C,iBAAL,CAAuBhD,kBAAvB,EAA2CC,WAA3C,EAAwDC,UAAxD;;IACA,IAAI,KAAKyB,aAAL,IAAsB,KAAKA,aAAL,CAAmByC,YAA7C,EAA2D;MACvD,OAAO,KAAKzC,aAAL,CAAmByC,YAAnB,CAAgCpE,kBAAhC,EAAoDC,WAApD,EAAiEC,UAAjE,EAA6EC,IAA7E,EAAmF8D,SAAnF,EAA8FC,SAA9F,CAAP;IACH,CAFD,MAGK;MACD,OAAOlE,kBAAkB,CAACqE,UAAnB,CAA8BnE,UAA9B,EAA0CC,IAA1C,EAAgD8D,SAAhD,EAA2DC,SAA3D,CAAP;IACH;EACJ;;EACDI,YAAY,CAACtE,kBAAD,EAAqBC,WAArB,EAAkCC,UAAlC,EAA8CC,IAA9C,EAAoD;IAC5D,IAAIA,IAAI,CAACI,IAAL,KAAc,WAAlB,EAA+B;MAC3B,KAAK2C,eAAL,CAAqB/C,IAArB;IACH;;IACD,KAAK6C,iBAAL,CAAuBhD,kBAAvB,EAA2CC,WAA3C,EAAwDC,UAAxD;;IACA,IAAI,KAAKyB,aAAL,IAAsB,KAAKA,aAAL,CAAmB2C,YAA7C,EAA2D;MACvD,OAAO,KAAK3C,aAAL,CAAmB2C,YAAnB,CAAgCtE,kBAAhC,EAAoDC,WAApD,EAAiEC,UAAjE,EAA6EC,IAA7E,CAAP;IACH,CAFD,MAGK;MACD,OAAOH,kBAAkB,CAACuE,UAAnB,CAA8BrE,UAA9B,EAA0CC,IAA1C,CAAP;IACH;EACJ;;EACD8C,SAAS,CAACa,QAAD,EAAW3B,OAAX,EAAoBqC,MAApB,EAA4BC,YAA5B,EAA0C;IAC/C,KAAK3C,aAAL,GAAqB2C,YAArB;;IACA,IAAI,KAAK9C,aAAL,IAAsB,KAAKA,aAAL,CAAmBsB,SAA7C,EAAwD;MACpD,KAAKtB,aAAL,CAAmBsB,SAAnB,CAA6Ba,QAA7B,EAAuC3B,OAAvC,EAAgDqC,MAAhD,EAAwDC,YAAxD;IACH,CAFD,MAGK;MACDX,QAAQ,CAACY,OAAT,CAAiBF,MAAjB,EAAyBC,YAAzB;IACH;EACJ;;AA/Je,C,CAiKpB;AACA;;;AACAhF,IAAI,CAAC,eAAD,CAAJ,GAAwBgC,aAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMkD,gBAAN,CAAuB;EACnBnH,WAAW,CAACoH,UAAD,EAAa;IACpB,KAAKC,OAAL,GAAepF,IAAI,CAAC0C,OAApB;IACA,KAAKzC,IAAL,GAAY,sBAAsBkF,UAAlC;EACH;;EACD7E,cAAc,CAAC+D,QAAD,EAAW3B,OAAX,EAAoBqC,MAApB,EAA4BrE,IAA5B,EAAkC;IAC5C,QAAQA,IAAI,CAACI,IAAb;MACI,KAAK,WAAL;MACA,KAAK,WAAL;QACI,MAAM,IAAIzC,KAAJ,CAAW,eAAcqC,IAAI,CAACqD,MAAO,2BAArC,CAAN;;MACJ,KAAK,WAAL;QACIrD,IAAI,GAAG2D,QAAQ,CAACpD,YAAT,CAAsB8D,MAAtB,EAA8BrE,IAA9B,CAAP;QACA;IANR;;IAQA,OAAOA,IAAP;EACH;;AAfkB,C,CAiBvB;AACA;;;AACAV,IAAI,CAAC,kBAAD,CAAJ,GAA2BkF,gBAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAlF,IAAI,CAACqF,YAAL,CAAkB,SAAlB,EAA6B,CAACC,MAAD,EAAStF,IAAT,EAAeuF,GAAf,KAAuB;EAChD,MAAMC,SAAS,GAAG,UAAUC,CAAV,EAAaC,CAAb,EAAgB;IAC9B,KAAK,MAAMC,CAAX,IAAgBD,CAAhB,EACI,IAAIA,CAAC,CAACxG,cAAF,CAAiByG,CAAjB,CAAJ,EACIF,CAAC,CAACE,CAAD,CAAD,GAAOD,CAAC,CAACC,CAAD,CAAR;;IACR,SAASC,EAAT,GAAc;MACV,KAAK7H,WAAL,GAAmB0H,CAAnB;IACH;;IACDA,CAAC,CAACI,SAAF,GAAcH,CAAC,KAAK,IAAN,GAAa3E,MAAM,CAAC+E,MAAP,CAAcJ,CAAd,CAAb,IAAkCE,EAAE,CAACC,SAAH,GAAeH,CAAC,CAACG,SAAlB,EAA8B,IAAID,EAAJ,EAA/D,CAAd;EACH,CARD,CADgD,CAUhD;EACA;;;EACA,IAAI,CAAC5F,IAAL,EACI,MAAM,IAAI3B,KAAJ,CAAU,kBAAV,CAAN;;EACJ,IAAI,OAAO0H,IAAP,KAAgB,WAApB,EAAiC;IAC7B;IACA;IACA;EACH;;EACD,IAAI,OAAOC,OAAP,IAAkB,WAAlB,IAAiCA,OAAO,CAAC,gBAAD,CAA5C,EAAgE;IAC5D;EACH;;EACDA,OAAO,CAAC,gBAAD,CAAP,GAA4B,IAA5B;EACA,MAAMd,gBAAgB,GAAGlF,IAAI,CAAC,kBAAD,CAA7B;EACA,MAAMgC,aAAa,GAAGhC,IAAI,CAAC,eAAD,CAA1B;EACA,IAAI,CAACkF,gBAAL,EACI,MAAM,IAAI7G,KAAJ,CAAU,2BAAV,CAAN;EACJ,IAAI,CAAC2D,aAAL,EACI,MAAM,IAAI3D,KAAJ,CAAU,wBAAV,CAAN;EACJ,MAAM4H,WAAW,GAAGjG,IAAI,CAAC0C,OAAzB,CA7BgD,CA8BhD;EACA;EACA;;EACA,MAAMwD,QAAQ,GAAGD,WAAW,CAAC9B,IAAZ,CAAiB,IAAIe,gBAAJ,CAAqB,kBAArB,CAAjB,CAAjB;EACA,MAAMiB,MAAM,GAAGnG,IAAI,CAACK,UAApB,CAlCgD,CAmChD;;EACA,MAAM+F,2BAA2B,GAAGd,MAAM,CAACa,MAAM,CAAC,+BAAD,CAAP,CAAN,KAAoD,IAAxF,CApCgD,CAqChD;EACA;EACA;;EACA,MAAME,mCAAmC,GAAG,CAACD,2BAAD,KACtCd,MAAM,CAACa,MAAM,CAAC,oBAAD,CAAP,CAAN,KAAyC,IAA1C,IACIb,MAAM,CAACa,MAAM,CAAC,wCAAD,CAAP,CAAN,KAA6D,IAF1B,CAA5C;EAGA,MAAMG,wBAAwB,GAAGhB,MAAM,CAACa,MAAM,CAAC,0BAAD,CAAP,CAAN,KAA+C,IAAhF;;EACA,IAAI,CAACG,wBAAL,EAA+B;IAC3B,MAAMC,YAAY,GAAGP,OAAO,CAACQ,YAA7B;;IACA,IAAID,YAAY,IAAI,CAACP,OAAO,CAACG,MAAM,CAAC,cAAD,CAAP,CAA5B,EAAsD;MAClDH,OAAO,CAACG,MAAM,CAAC,cAAD,CAAP,CAAP,GAAkCI,YAAlC;;MACAP,OAAO,CAACQ,YAAR,GAAuB,YAAY;QAC/B,MAAMC,QAAQ,GAAG,IAAIF,YAAJ,EAAjB;QACA,MAAMG,eAAe,GAAGD,QAAQ,CAACE,OAAjC;;QACA,IAAID,eAAe,IAAI,CAACD,QAAQ,CAACN,MAAM,CAAC,SAAD,CAAP,CAAhC,EAAqD;UACjDM,QAAQ,CAACN,MAAM,CAAC,SAAD,CAAP,CAAR,GAA8BO,eAA9B;;UACAD,QAAQ,CAACE,OAAT,GAAmB,YAAY;YAC3B,MAAMC,gBAAgB,GAAGC,OAAO,CAACC,SAAR,CAAkB,oBAAlB,CAAzB;YACA,MAAMC,CAAC,GAAGL,eAAe,CAACM,KAAhB,CAAsB,IAAtB,EAA4BC,SAA5B,CAAV;YACAJ,OAAO,CAACK,kBAAR,CAA2B,oBAA3B;;YACA,IAAIN,gBAAJ,EAAsB;cAClBA,gBAAgB,CAAC7D,OAAjB,CAAyBoE,CAAC,IAAIN,OAAO,CAACO,EAAR,CAAW,oBAAX,EAAiCD,CAAjC,CAA9B;YACH;;YACD,OAAOJ,CAAP;UACH,CARD;QASH;;QACD,OAAON,QAAP;MACH,CAhBD;IAiBH;EACJ,CAlE+C,CAmEhD;;;EACA,MAAMY,UAAU,GAAGrB,OAAO,CAACsB,MAAR,EAAnB;EACA,CAAC,UAAD,EAAa,WAAb,EAA0B,WAA1B,EAAuCvE,OAAvC,CAA+CwE,UAAU,IAAI;IACzD,IAAIC,iBAAiB,GAAGH,UAAU,CAACE,UAAD,CAAlC;;IACAF,UAAU,CAACE,UAAD,CAAV,GAAyB,UAAUE,WAAV,EAAuBC,eAAvB,EAAwC;MAC7D,OAAOF,iBAAiB,CAACG,IAAlB,CAAuB,IAAvB,EAA6BF,WAA7B,EAA0CG,kBAAkB,CAACF,eAAD,CAA5D,CAAP;IACH,CAFD;EAGH,CALD;EAMA,CAAC,IAAD,EAAO,KAAP,EAAc,KAAd,EAAqB3E,OAArB,CAA6BwE,UAAU,IAAI;IACvC,IAAIC,iBAAiB,GAAGH,UAAU,CAACE,UAAD,CAAlC;IACAF,UAAU,CAAClB,MAAM,CAACoB,UAAD,CAAP,CAAV,GAAiCC,iBAAjC;;IACAH,UAAU,CAACE,UAAD,CAAV,GAAyB,UAAUE,WAAV,EAAuBC,eAAvB,EAAwCG,OAAxC,EAAiD;MACtEZ,SAAS,CAAC,CAAD,CAAT,GAAea,cAAc,CAACJ,eAAD,CAA7B;MACA,OAAOF,iBAAiB,CAACR,KAAlB,CAAwB,IAAxB,EAA8BC,SAA9B,CAAP;IACH,CAHD;EAIH,CAPD;EAQA,CAAC,YAAD,EAAe,WAAf,EAA4B,WAA5B,EAAyC,UAAzC,EAAqDlE,OAArD,CAA6DwE,UAAU,IAAI;IACvE,IAAIC,iBAAiB,GAAGH,UAAU,CAACE,UAAD,CAAlC;IACAF,UAAU,CAAClB,MAAM,CAACoB,UAAD,CAAP,CAAV,GAAiCC,iBAAjC;;IACAH,UAAU,CAACE,UAAD,CAAV,GAAyB,UAAUG,eAAV,EAA2BG,OAA3B,EAAoC;MACzDZ,SAAS,CAAC,CAAD,CAAT,GAAea,cAAc,CAACJ,eAAD,CAA7B;MACA,OAAOF,iBAAiB,CAACR,KAAlB,CAAwB,IAAxB,EAA8BC,SAA9B,CAAP;IACH,CAHD;EAIH,CAPD;;EAQA,IAAI,CAACb,2BAAL,EAAkC;IAC9B;IACA;IACA,MAAM2B,eAAe,GAAI/B,OAAO,CAACG,MAAM,CAAC,OAAD,CAAP,CAAP,GAA2BH,OAAO,CAAC,OAAD,CAA3D;;IACAA,OAAO,CAAC,OAAD,CAAP,GAAmB,YAAY;MAC3B,MAAMgC,KAAK,GAAGD,eAAe,CAACf,KAAhB,CAAsB,IAAtB,EAA4BC,SAA5B,CAAd;;MACA,IAAI,CAACe,KAAK,CAAC7B,MAAM,CAAC,SAAD,CAAP,CAAV,EAA+B;QAC3B6B,KAAK,CAAC7B,MAAM,CAAC,SAAD,CAAP,CAAL,GAA2BA,MAAM,CAAC,SAAD,CAAjC;QACA,MAAM8B,YAAY,GAAID,KAAK,CAAC7B,MAAM,CAAC,MAAD,CAAP,CAAL,GAAwB6B,KAAK,CAACE,IAApD;;QACAF,KAAK,CAACE,IAAN,GAAa,YAAY;UACrB,MAAMC,iBAAiB,GAAGnI,IAAI,CAAC0C,OAAL,CAAaD,GAAb,CAAiB,uBAAjB,CAA1B;;UACA,IAAI0F,iBAAJ,EAAuB;YACnB,OAAOA,iBAAiB,CAACD,IAAlB,CAAuBlB,KAAvB,CAA6BmB,iBAA7B,EAAgDlB,SAAhD,CAAP;UACH;;UACD,OAAOgB,YAAY,CAACjB,KAAb,CAAmB,IAAnB,EAAyBC,SAAzB,CAAP;QACH,CAND;;QAOA,MAAMmB,gBAAgB,GAAIJ,KAAK,CAAC7B,MAAM,CAAC,UAAD,CAAP,CAAL,GAA4B6B,KAAK,CAACK,QAA5D;;QACAL,KAAK,CAACK,QAAN,GAAiB,YAAY;UACzB,MAAMF,iBAAiB,GAAGnI,IAAI,CAAC0C,OAAL,CAAaD,GAAb,CAAiB,uBAAjB,CAA1B;;UACA,IAAI0F,iBAAJ,EAAuB;YACnB,MAAMG,QAAQ,GAAGrB,SAAS,CAACjI,MAAV,GAAmB,CAAnB,GAAuBiI,SAAS,CAAC,CAAD,CAAhC,GAAsC,IAAI9I,IAAJ,EAAvD;YACA,OAAOgK,iBAAiB,CAACI,qBAAlB,CAAwCvB,KAAxC,CAA8CmB,iBAA9C,EAAiEG,QAAQ,IAAI,OAAOA,QAAQ,CAAC9I,OAAhB,KAA4B,UAAxC,GAAqD,CAAC8I,QAAQ,CAAC9I,OAAT,EAAD,CAArD,GACpEyH,SADG,CAAP;UAEH;;UACD,OAAOmB,gBAAgB,CAACpB,KAAjB,CAAuB,IAAvB,EAA6BC,SAA7B,CAAP;QACH,CARD,CAX2B,CAoB3B;;;QACA,IAAIZ,mCAAJ,EAAyC;UACrC,CAAC,SAAD,EAAY,WAAZ,EAAyBtD,OAAzB,CAAiCwE,UAAU,IAAI;YAC3C,MAAMQ,eAAe,GAAIC,KAAK,CAAC7B,MAAM,CAACoB,UAAD,CAAP,CAAL,GAA4BS,KAAK,CAACT,UAAD,CAA1D;;YACAS,KAAK,CAACT,UAAD,CAAL,GAAoB,YAAY;cAC5B,MAAMiB,qBAAqB,GAAGxI,IAAI,CAAC,uBAAD,CAAlC;;cACA,IAAIwI,qBAAJ,EAA2B;gBACvBxC,OAAO,CAACG,MAAM,CAAC,gBAAD,CAAP,CAAP,GAAoC,cAAcoB,UAAlD;gBACA;cACH;;cACD,OAAOQ,eAAe,CAACf,KAAhB,CAAsB,IAAtB,EAA4BC,SAA5B,CAAP;YACH,CAPD;UAQH,CAVD;QAWH;MACJ;;MACD,OAAOe,KAAP;IACH,CAtCD;EAuCH,CAtI+C,CAuIhD;;;EACA,IAAI,CAAChC,OAAO,CAAChG,IAAI,CAACK,UAAL,CAAgB,cAAhB,CAAD,CAAZ,EAA+C;IAC3C,MAAMoI,oBAAoB,GAAGzC,OAAO,CAAC0C,YAArC;IACA1C,OAAO,CAAChG,IAAI,CAACK,UAAL,CAAgB,cAAhB,CAAD,CAAP,GAA2CoI,oBAA3C;;IACAzC,OAAO,CAAC0C,YAAR,GAAuB,YAAY;MAC/B,MAAMC,IAAI,GAAGC,KAAK,CAAC/C,SAAN,CAAgBgD,KAAhB,CAAsBlB,IAAtB,CAA2BV,SAA3B,CAAb;MACA,MAAM6B,aAAa,GAAGH,IAAI,CAAC3J,MAAL,IAAe,CAAf,GAAmB2J,IAAI,CAAC,CAAD,CAAvB,GAA6B,IAAnD;MACA,IAAII,MAAJ;;MACA,IAAID,aAAJ,EAAmB;QACf,MAAME,cAAc,GAAGjI,MAAM,CAACiI,cAA9B;;QACAjI,MAAM,CAACiI,cAAP,GAAwB,UAAUC,GAAV,EAAetD,CAAf,EAAkBuD,UAAlB,EAA8B;UAClD,OAAOF,cAAc,CAACrB,IAAf,CAAoB,IAApB,EAA0BsB,GAA1B,EAA+BtD,CAA/B,EAAkC5E,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBkI,UAAlB,CAAd,EAA6C;YAAEC,YAAY,EAAE,IAAhB;YAAsBC,UAAU,EAAE;UAAlC,CAA7C,CAAlC,CAAP;QACH,CAFD;;QAGA,IAAI;UACAL,MAAM,GAAGN,oBAAoB,CAACzB,KAArB,CAA2B,IAA3B,EAAiC2B,IAAjC,CAAT;QACH,CAFD,SAGQ;UACJ5H,MAAM,CAACiI,cAAP,GAAwBA,cAAxB;QACH;MACJ,CAXD,MAYK;QACDD,MAAM,GAAGN,oBAAoB,CAACzB,KAArB,CAA2B,IAA3B,EAAiC2B,IAAjC,CAAT;MACH;;MACD,OAAOI,MAAP;IACH,CApBD;EAqBH;EACD;AACJ;AACA;AACA;;;EACI,SAASnB,kBAAT,CAA4ByB,YAA5B,EAA0C;IACtC,OAAO,YAAY;MACf,OAAOnD,QAAQ,CAACoD,GAAT,CAAaD,YAAb,EAA2B,IAA3B,EAAiCpC,SAAjC,CAAP;IACH,CAFD;EAGH;;EACD,SAASsC,aAAT,CAAuBC,QAAvB,EAAiChF,SAAjC,EAA4CiF,WAA5C,EAAyDC,IAAzD,EAA+D;IAC3D,MAAMC,gBAAgB,GAAG,CAAC,CAAC3D,OAAO,CAACG,MAAM,CAAC,gBAAD,CAAP,CAAlC;IACAsD,WAAW,CAACG,iBAAZ;IACA,MAAMC,aAAa,GAAGJ,WAAW,CAACI,aAAlC;;IACA,IAAIF,gBAAgB,IAAItD,mCAAxB,EAA6D;MACzD;MACA,MAAMyD,eAAe,GAAG9J,IAAI,CAACA,IAAI,CAACK,UAAL,CAAgB,eAAhB,CAAD,CAA5B;;MACA,IAAIyJ,eAAe,IAAI,OAAOA,eAAe,CAACC,SAAvB,KAAqC,UAA5D,EAAwE;QACpEP,QAAQ,GAAGM,eAAe,CAACC,SAAhB,CAA0BP,QAA1B,CAAX;MACH;IACJ;;IACD,IAAIE,IAAJ,EAAU;MACN,OAAOG,aAAa,CAACP,GAAd,CAAkBE,QAAlB,EAA4BhF,SAA5B,EAAuC,CAACkF,IAAD,CAAvC,CAAP;IACH,CAFD,MAGK;MACD,OAAOG,aAAa,CAACP,GAAd,CAAkBE,QAAlB,EAA4BhF,SAA5B,CAAP;IACH;EACJ;EACD;AACJ;AACA;AACA;AACA;;;EACI,SAASsD,cAAT,CAAwB0B,QAAxB,EAAkC;IAC9B;IACA;IACA;IACA,OAAQA,QAAQ,KAAKA,QAAQ,CAACxK,MAAT,GAAkB,UAAU0K,IAAV,EAAgB;MACnD,OAAOH,aAAa,CAACC,QAAD,EAAW,IAAX,EAAiB,KAAKC,WAAtB,EAAmCC,IAAnC,CAApB;IACH,CAFoB,GAEjB,YAAY;MACZ,OAAOH,aAAa,CAACC,QAAD,EAAW,IAAX,EAAiB,KAAKC,WAAtB,CAApB;IACH,CAJe,CAAhB;EAKH;;EACD,MAAMO,WAAW,GAAGhE,OAAO,CAACgE,WAA5B;;EACAhE,OAAO,CAACgE,WAAR,GAAuB,UAAUC,MAAV,EAAkB;IACrCzE,SAAS,CAAC0E,eAAD,EAAkBD,MAAlB,CAAT;;IACA,SAASC,eAAT,CAAyBC,KAAzB,EAAgC;MAC5B,IAAIA,KAAK,CAACC,UAAV,EAAsB;QAClBD,KAAK,CAACC,UAAN,GAAmB,CAACC,EAAE,IAAI,MAAM;UAC5B;UACA,KAAKR,aAAL,GAAqB,IAArB;UACA,KAAKD,iBAAL,GAAyB,IAAzB;UACA3D,WAAW,CAACqE,iBAAZ,CAA8B,oBAA9B,EAAoDD,EAApD;QACH,CALkB,EAKhBF,KAAK,CAACC,UALU,CAAnB;MAMH;;MACD,MAAMG,gBAAgB,GAAGjF,MAAM,CAACtF,IAAI,CAACK,UAAL,CAAgB,YAAhB,CAAD,CAA/B;;MACA,MAAMmK,kBAAkB,GAAGlF,MAAM,CAACtF,IAAI,CAACK,UAAL,CAAgB,cAAhB,CAAD,CAAjC;;MACA,IAAIkK,gBAAJ,EAAsB;QAClB;QACAJ,KAAK,CAACtC,OAAN,GAAgB;UACZ4C,UAAU,EAAEF,gBAAgB,GAAGA,gBAAH,GAAsBjF,MAAM,CAACmF,UAD7C;UAEZC,YAAY,EAAEF,kBAAkB,GAAGA,kBAAH,GAAwBlF,MAAM,CAACoF;QAFnD,CAAhB;MAIH,CAjB2B,CAkB5B;MACA;;;MACA,IAAI1E,OAAO,CAAC2E,WAAZ,EAAyB;QACrB,IAAI,CAACR,KAAK,CAACS,WAAX,EAAwB;UACpBT,KAAK,CAACS,WAAN,GAAoB,IAAI5E,OAAO,CAAC2E,WAAZ,EAApB;QACH;;QACDR,KAAK,CAACS,WAAN,CAAkBnB,WAAlB,GAAgC,IAAhC;MACH,CALD,MAMK;QACD,IAAI,CAACU,KAAK,CAACS,WAAX,EAAwB;UACpBT,KAAK,CAACS,WAAN,GAAoB,EAApB;QACH;;QACDT,KAAK,CAACS,WAAN,CAAkBnB,WAAlB,GAAgC,IAAhC;MACH,CA/B2B,CAgC5B;;;MACA,MAAMoB,WAAW,GAAGV,KAAK,CAACU,WAA1B;;MACAV,KAAK,CAACU,WAAN,GAAoB,UAAU7M,KAAV,EAAiB;QACjC,IAAIA,KAAK,IACLA,KAAK,CAAC8M,OAAN,KACI,wGAFR,EAEkH;UAC9G;UACA;UACA,MAAMC,aAAa,GAAG,QAAQ,KAAKnB,iBAAnC;;UACA,IAAImB,aAAJ,EAAmB;YACf,MAAM/G,gBAAgB,GAAG+G,aAAa,CAACpH,2BAAd,EAAzB;;YACA,IAAI;cACA;cACA3F,KAAK,CAAC8M,OAAN,IAAiB9G,gBAAjB;YACH,CAHD,CAIA,OAAOzF,GAAP,EAAY,CACX;UACJ;QACJ;;QACD,IAAIsM,WAAJ,EAAiB;UACbA,WAAW,CAAClD,IAAZ,CAAiB,IAAjB,EAAuB3J,KAAvB;QACH;MACJ,CApBD;;MAqBAiM,MAAM,CAACtC,IAAP,CAAY,IAAZ,EAAkBwC,KAAlB;IACH;;IACDD,eAAe,CAACrE,SAAhB,CAA0BmF,OAA1B,GAAoC,YAAY;MAC5C,IAAIC,IAAI,GAAGjL,IAAI,CAAC0C,OAAhB;MACA,IAAIwI,oBAAoB,GAAG,KAA3B;;MACA,OAAOD,IAAP,EAAa;QACT,IAAIA,IAAI,KAAKhF,WAAb,EAA0B;UACtBiF,oBAAoB,GAAG,IAAvB;UACA;QACH;;QACDD,IAAI,GAAGA,IAAI,CAACE,MAAZ;MACH;;MACD,IAAI,CAACD,oBAAL,EACI,MAAM,IAAI7M,KAAJ,CAAU,sBAAsB2B,IAAI,CAAC0C,OAAL,CAAazC,IAA7C,CAAN,CAXwC,CAY5C;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;MACA,KAAK2J,iBAAL,GAAyB,IAAI5H,aAAJ,EAAzB;MACA,KAAK6H,aAAL,GAAqB5D,WAAW,CAAC9B,IAAZ,CAAiB,KAAKyF,iBAAtB,CAArB;;MACA,IAAI,CAAC5J,IAAI,CAACW,WAAV,EAAuB;QACnB;QACA;QACA;QACA;QACA;QACAX,IAAI,CAAC0C,OAAL,CAAa4H,iBAAb,CAA+B,6BAA/B,EAA8D,MAAMN,WAAW,CAACnE,SAAZ,CAAsBmF,OAAtB,CAA8BrD,IAA9B,CAAmC,IAAnC,CAApE;MACH,CAPD,MAQK;QACDsC,MAAM,CAACpE,SAAP,CAAiBmF,OAAjB,CAAyBrD,IAAzB,CAA8B,IAA9B;MACH;IACJ,CAlCD;;IAmCA,OAAOuC,eAAP;EACH,CA/FqB,CA+FnBF,WA/FmB,CAAtB;AAgGH,CA5SD;AA8SA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAhK,IAAI,CAACqF,YAAL,CAAkB,MAAlB,EAA0B,CAAC+F,OAAD,EAAUpL,IAAV,EAAgBuF,GAAhB,KAAwB;EAC9C,IAAI,OAAOQ,IAAP,KAAgB,WAAhB,IAA+BA,IAAI,CAAC,gBAAD,CAAvC,EAA2D;IACvD;EACH;;EACDA,IAAI,CAAC,gBAAD,CAAJ,GAAyB,IAAzB;EACA,MAAM/D,aAAa,GAAGhC,IAAI,CAAC,eAAD,CAA1B;EACA,MAAMkF,gBAAgB,GAAGlF,IAAI,CAAC,kBAAD,CAA7B;;EACA,IAAI,CAACgC,aAAL,EAAoB;IAChB,MAAM,IAAI3D,KAAJ,CAAU,uBAAV,CAAN;EACH;;EACD,MAAMgN,QAAQ,GAAGrL,IAAI,CAAC0C,OAAtB;EACA,MAAMwD,QAAQ,GAAGmF,QAAQ,CAAClH,IAAT,CAAc,IAAIe,gBAAJ,CAAqB,eAArB,CAAd,CAAjB;EACA,MAAM6F,aAAa,GAAG,IAAI/I,aAAJ,EAAtB;EACA,MAAMsJ,SAAS,GAAGD,QAAQ,CAAClH,IAAT,CAAc4G,aAAd,CAAlB;;EACA,SAASQ,yBAAT,CAAmCC,cAAnC,EAAmD;IAC/C,OAAO,UAAU,GAAGC,SAAb,EAAwB;MAC3B,MAAMC,kBAAkB,GAAGF,cAAc,CAACxE,KAAf,CAAqB,IAArB,EAA2ByE,SAA3B,CAA3B;MACA,OAAO,UAAU,GAAG9C,IAAb,EAAmB;QACtBA,IAAI,CAAC,CAAD,CAAJ,GAAUf,kBAAkB,CAACe,IAAI,CAAC,CAAD,CAAL,CAA5B;QACA,OAAO+C,kBAAkB,CAAC1E,KAAnB,CAAyB,IAAzB,EAA+B2B,IAA/B,CAAP;MACH,CAHD;IAIH,CAND;EAOH;;EACD,SAASgD,qBAAT,CAA+BH,cAA/B,EAA+C;IAC3C,OAAO,UAAU,GAAGC,SAAb,EAAwB;MAC3B,OAAO,UAAU,GAAG9C,IAAb,EAAmB;QACtBA,IAAI,CAAC,CAAD,CAAJ,GAAUb,cAAc,CAACa,IAAI,CAAC,CAAD,CAAL,CAAxB;QACA,OAAO6C,cAAc,CAACxE,KAAf,CAAqB,IAArB,EAA2ByE,SAA3B,EAAsCzE,KAAtC,CAA4C,IAA5C,EAAkD2B,IAAlD,CAAP;MACH,CAHD;IAIH,CALD;EAMH;EACD;AACJ;AACA;AACA;;;EACI,SAASf,kBAAT,CAA4ByB,YAA5B,EAA0C;IACtC,OAAO,UAAU,GAAGV,IAAb,EAAmB;MACtB,OAAOzC,QAAQ,CAACoD,GAAT,CAAaD,YAAb,EAA2B,IAA3B,EAAiCV,IAAjC,CAAP;IACH,CAFD;EAGH;EACD;AACJ;AACA;AACA;AACA;;;EACI,SAASb,cAAT,CAAwB0B,QAAxB,EAAkCoC,UAAU,GAAG,KAA/C,EAAsD;IAClD,IAAI,OAAOpC,QAAP,KAAoB,UAAxB,EAAoC;MAChC,OAAOA,QAAP;IACH;;IACD,MAAMqC,WAAW,GAAG,YAAY;MAC5B,IAAI7L,IAAI,CAACuF,GAAG,CAACY,MAAJ,CAAW,qBAAX,CAAD,CAAJ,KAA4C,IAA5C,IAAoDqD,QAApD,IACA,CAACA,QAAQ,CAACsC,WADd,EAC2B;QACvB;QACA,MAAMhC,eAAe,GAAG9J,IAAI,CAACA,IAAI,CAACK,UAAL,CAAgB,eAAhB,CAAD,CAA5B;;QACA,IAAIyJ,eAAe,IAAI,OAAOA,eAAe,CAACC,SAAvB,KAAqC,UAA5D,EAAwE;UACpEP,QAAQ,GAAGM,eAAe,CAACC,SAAhB,CAA0BP,QAA1B,CAAX;QACH;MACJ;;MACDuB,aAAa,CAACa,UAAd,GAA2BA,UAA3B;MACA,OAAON,SAAS,CAAChC,GAAV,CAAcE,QAAd,EAAwB,IAAxB,EAA8BvC,SAA9B,CAAP;IACH,CAXD,CAJkD,CAgBlD;IACA;;;IACAlG,MAAM,CAACiI,cAAP,CAAsB6C,WAAtB,EAAmC,QAAnC,EAA6C;MAAE1C,YAAY,EAAE,IAAhB;MAAsB4C,QAAQ,EAAE,IAAhC;MAAsC3C,UAAU,EAAE;IAAlD,CAA7C;IACAyC,WAAW,CAAC7M,MAAZ,GAAqBwK,QAAQ,CAACxK,MAA9B;IACA,OAAO6M,WAAP;EACH;;EACD,CAAC,UAAD,EAAa,WAAb,EAA0B,WAA1B,EAAuC9I,OAAvC,CAA+CwE,UAAU,IAAI;IACzD,IAAIiE,cAAc,GAAGJ,OAAO,CAAC7D,UAAD,CAA5B;;IACA,IAAI6D,OAAO,CAACpL,IAAI,CAACK,UAAL,CAAgBkH,UAAhB,CAAD,CAAX,EAA0C;MACtC;IACH;;IACD6D,OAAO,CAACpL,IAAI,CAACK,UAAL,CAAgBkH,UAAhB,CAAD,CAAP,GAAuCiE,cAAvC;;IACAJ,OAAO,CAAC7D,UAAD,CAAP,GAAsB,UAAU,GAAGoB,IAAb,EAAmB;MACrCA,IAAI,CAAC,CAAD,CAAJ,GAAUf,kBAAkB,CAACe,IAAI,CAAC,CAAD,CAAL,CAA5B;MACA,OAAO6C,cAAc,CAACxE,KAAf,CAAqB,IAArB,EAA2B2B,IAA3B,CAAP;IACH,CAHD;;IAIAyC,OAAO,CAAC7D,UAAD,CAAP,CAAoByE,IAApB,GAA2BT,yBAAyB,CAACC,cAAc,CAACQ,IAAhB,CAApD;EACH,CAXD;EAYAZ,OAAO,CAACa,QAAR,CAAiBC,IAAjB,GAAwBd,OAAO,CAACe,SAAhC;EACAf,OAAO,CAACa,QAAR,CAAiBG,IAAjB,GAAwBhB,OAAO,CAACiB,SAAhC;EACA,CAAC,IAAD,EAAO,KAAP,EAAc,KAAd,EAAqB,MAArB,EAA6B,OAA7B,EAAsCtJ,OAAtC,CAA8CwE,UAAU,IAAI;IACxD,IAAIiE,cAAc,GAAGJ,OAAO,CAAC7D,UAAD,CAA5B;;IACA,IAAI6D,OAAO,CAACpL,IAAI,CAACK,UAAL,CAAgBkH,UAAhB,CAAD,CAAX,EAA0C;MACtC;IACH;;IACD6D,OAAO,CAACpL,IAAI,CAACK,UAAL,CAAgBkH,UAAhB,CAAD,CAAP,GAAuCiE,cAAvC;;IACAJ,OAAO,CAAC7D,UAAD,CAAP,GAAsB,UAAU,GAAGoB,IAAb,EAAmB;MACrCA,IAAI,CAAC,CAAD,CAAJ,GAAUb,cAAc,CAACa,IAAI,CAAC,CAAD,CAAL,EAAU,IAAV,CAAxB;MACA,OAAO6C,cAAc,CAACxE,KAAf,CAAqB,IAArB,EAA2B2B,IAA3B,CAAP;IACH,CAHD;;IAIAyC,OAAO,CAAC7D,UAAD,CAAP,CAAoByE,IAApB,GAA2BL,qBAAqB,CAACH,cAAc,CAACQ,IAAhB,CAAhD;IACAZ,OAAO,CAAC7D,UAAD,CAAP,CAAoB+E,IAApB,GAA2Bd,cAAc,CAACc,IAA1C;EACH,CAZD;EAaAlB,OAAO,CAACmB,EAAR,CAAWL,IAAX,GAAkBd,OAAO,CAACoB,GAA1B;EACApB,OAAO,CAACmB,EAAR,CAAWH,IAAX,GAAkBhB,OAAO,CAACqB,GAA1B;EACArB,OAAO,CAACsB,IAAR,CAAaR,IAAb,GAAoBd,OAAO,CAACoB,GAA5B;EACApB,OAAO,CAACsB,IAAR,CAAaN,IAAb,GAAoBhB,OAAO,CAACqB,GAA5B;EACA,CAAC,YAAD,EAAe,WAAf,EAA4B,WAA5B,EAAyC,UAAzC,EAAqD1J,OAArD,CAA6DwE,UAAU,IAAI;IACvE,IAAIiE,cAAc,GAAGJ,OAAO,CAAC7D,UAAD,CAA5B;;IACA,IAAI6D,OAAO,CAACpL,IAAI,CAACK,UAAL,CAAgBkH,UAAhB,CAAD,CAAX,EAA0C;MACtC;IACH;;IACD6D,OAAO,CAACpL,IAAI,CAACK,UAAL,CAAgBkH,UAAhB,CAAD,CAAP,GAAuCiE,cAAvC;;IACAJ,OAAO,CAAC7D,UAAD,CAAP,GAAsB,UAAU,GAAGoB,IAAb,EAAmB;MACrCA,IAAI,CAAC,CAAD,CAAJ,GAAUb,cAAc,CAACa,IAAI,CAAC,CAAD,CAAL,CAAxB;MACA,OAAO6C,cAAc,CAACxE,KAAf,CAAqB,IAArB,EAA2B2B,IAA3B,CAAP;IACH,CAHD;EAIH,CAVD;;EAWA3I,IAAI,CAAC2M,eAAL,GAAuB,SAASA,eAAT,CAAyBC,KAAzB,EAAgCC,QAAQ,GAAG,KAA3C,EAAkD;IACrE;IACA,SAASC,mBAAT,GAA+B;MAC3B,MAAM3E,iBAAiB,GAAGnI,IAAI,CAAC0C,OAAL,CAAaD,GAAb,CAAiB,uBAAjB,CAA1B;MACA,OAAO,CAAC,CAAC0F,iBAAT;IACH,CALoE,CAMrE;IACA;;;IACA,SAAS4E,YAAT,GAAwB;MACpB,MAAMhC,aAAa,GAAG/K,IAAI,CAAC0C,OAAL,CAAaD,GAAb,CAAiB,eAAjB,CAAtB;MACA,OAAOsI,aAAa,IAAIA,aAAa,CAACa,UAAtC;IACH;;IACD,IAAIgB,KAAK,CAACrH,GAAG,CAACY,MAAJ,CAAW,YAAX,CAAD,CAAT,EAAqC;MACjC;IACH;;IACDyG,KAAK,CAACrH,GAAG,CAACY,MAAJ,CAAW,YAAX,CAAD,CAAL,GAAkC,IAAlC,CAfqE,CAgBrE;;IACAZ,GAAG,CAACyH,WAAJ,CAAgBJ,KAAhB,EAAuB,kBAAvB,EAA2CvI,QAAQ,IAAI;MACnD,OAAO,UAAU4I,IAAV,EAAgBtE,IAAhB,EAAsB;QACzB,IAAImE,mBAAmB,EAAvB,EAA2B;UACvB,OAAO,IAAP;QACH,CAFD,MAGK;UACD,OAAOzI,QAAQ,CAAC2C,KAAT,CAAeiG,IAAf,EAAqBtE,IAArB,CAAP;QACH;MACJ,CAPD;IAQH,CATD,EAjBqE,CA2BrE;;IACApD,GAAG,CAACyH,WAAJ,CAAgBJ,KAAhB,EAAuB,eAAvB,EAAwCvI,QAAQ,IAAI;MAChD,OAAO,UAAU4I,IAAV,EAAgBtE,IAAhB,EAAsB;QACzB3I,IAAI,CAACuF,GAAG,CAACY,MAAJ,CAAW,qBAAX,CAAD,CAAJ,GAA0C,IAA1C;;QACA,IAAI0G,QAAQ,IAAIE,YAAY,EAA5B,EAAgC;UAC5B,OAAO1I,QAAQ,CAAC2C,KAAT,CAAeiG,IAAf,EAAqBtE,IAArB,CAAP;QACH;;QACD,OAAOsE,IAAP;MACH,CAND;IAOH,CARD,EA5BqE,CAqCrE;;IACA1H,GAAG,CAACyH,WAAJ,CAAgBJ,KAAhB,EAAuB,eAAvB,EAAwCvI,QAAQ,IAAI;MAChD,OAAO,UAAU4I,IAAV,EAAgBtE,IAAhB,EAAsB;QACzB3I,IAAI,CAACuF,GAAG,CAACY,MAAJ,CAAW,qBAAX,CAAD,CAAJ,GAA0C,KAA1C;;QACA,IAAI0G,QAAQ,IAAIE,YAAY,EAA5B,EAAgC;UAC5B,OAAO1I,QAAQ,CAAC2C,KAAT,CAAeiG,IAAf,EAAqBtE,IAArB,CAAP;QACH;;QACD,OAAOsE,IAAP;MACH,CAND;IAOH,CARD,EAtCqE,CA+CrE;;IACA1H,GAAG,CAACyH,WAAJ,CAAgBJ,KAAhB,EAAuB,eAAvB,EAAwCvI,QAAQ,IAAI;MAChD,OAAO,UAAU4I,IAAV,EAAgBtE,IAAhB,EAAsB;QACzB,MAAMR,iBAAiB,GAAGnI,IAAI,CAAC0C,OAAL,CAAaD,GAAb,CAAiB,uBAAjB,CAA1B;;QACA,IAAI0F,iBAAiB,IAAI2E,mBAAmB,EAA5C,EAAgD;UAC5C3E,iBAAiB,CAACI,qBAAlB,CAAwCI,IAAI,CAAC,CAAD,CAA5C;QACH,CAFD,MAGK;UACD,OAAOtE,QAAQ,CAAC2C,KAAT,CAAeiG,IAAf,EAAqBtE,IAArB,CAAP;QACH;MACJ,CARD;IASH,CAVD,EAhDqE,CA2DrE;;IACApD,GAAG,CAACyH,WAAJ,CAAgBJ,KAAhB,EAAuB,mBAAvB,EAA4CvI,QAAQ,IAAI;MACpD,OAAO,UAAU4I,IAAV,EAAgBtE,IAAhB,EAAsB;QACzB,MAAMR,iBAAiB,GAAGnI,IAAI,CAAC0C,OAAL,CAAaD,GAAb,CAAiB,uBAAjB,CAA1B;;QACA,IAAI0F,iBAAiB,IAAI2E,mBAAmB,EAA5C,EAAgD;UAC5C,OAAO3E,iBAAiB,CAAC+E,iBAAlB,EAAP;QACH,CAFD,MAGK;UACD,OAAO7I,QAAQ,CAAC2C,KAAT,CAAeiG,IAAf,EAAqBtE,IAArB,CAAP;QACH;MACJ,CARD;IASH,CAVD,EA5DqE,CAuErE;;IACApD,GAAG,CAACyH,WAAJ,CAAgBJ,KAAhB,EAAuB,aAAvB,EAAsCvI,QAAQ,IAAI;MAC9C,OAAO,UAAU4I,IAAV,EAAgBtE,IAAhB,EAAsB;QACzB,MAAMR,iBAAiB,GAAGnI,IAAI,CAAC0C,OAAL,CAAaD,GAAb,CAAiB,uBAAjB,CAA1B;;QACA,IAAI0F,iBAAJ,EAAuB;UACnBA,iBAAiB,CAACgF,eAAlB;QACH,CAFD,MAGK;UACD,OAAO9I,QAAQ,CAAC2C,KAAT,CAAeiG,IAAf,EAAqBtE,IAArB,CAAP;QACH;MACJ,CARD;IASH,CAVD,EAxEqE,CAmFrE;;IACApD,GAAG,CAACyH,WAAJ,CAAgBJ,KAAhB,EAAuB,cAAvB,EAAuCvI,QAAQ,IAAI;MAC/C,OAAO,UAAU4I,IAAV,EAAgBtE,IAAhB,EAAsB;QACzB,MAAMR,iBAAiB,GAAGnI,IAAI,CAAC0C,OAAL,CAAaD,GAAb,CAAiB,uBAAjB,CAA1B;;QACA,IAAI0F,iBAAJ,EAAuB;UACnBA,iBAAiB,CAACiF,KAAlB,CAAwB,GAAxB,EAA6B,IAA7B;QACH,CAFD,MAGK;UACD,OAAO/I,QAAQ,CAAC2C,KAAT,CAAeiG,IAAf,EAAqBtE,IAArB,CAAP;QACH;MACJ,CARD;IASH,CAVD,EApFqE,CA+FrE;;IACApD,GAAG,CAACyH,WAAJ,CAAgBJ,KAAhB,EAAuB,qBAAvB,EAA8CvI,QAAQ,IAAI;MACtD,OAAO,UAAU4I,IAAV,EAAgBtE,IAAhB,EAAsB;QACzB,MAAMR,iBAAiB,GAAGnI,IAAI,CAAC0C,OAAL,CAAaD,GAAb,CAAiB,uBAAjB,CAA1B;;QACA,IAAI0F,iBAAJ,EAAuB;UACnBA,iBAAiB,CAACD,IAAlB,CAAuBS,IAAI,CAAC,CAAD,CAA3B;QACH,CAFD,MAGK;UACD,OAAOtE,QAAQ,CAAC2C,KAAT,CAAeiG,IAAf,EAAqBtE,IAArB,CAAP;QACH;MACJ,CARD;IASH,CAVD,EAhGqE,CA2GrE;;IACApD,GAAG,CAACyH,WAAJ,CAAgBJ,KAAhB,EAAuB,sBAAvB,EAA+CvI,QAAQ,IAAI;MACvD,OAAO,UAAU4I,IAAV,EAAgBtE,IAAhB,EAAsB;QACzB,MAAMR,iBAAiB,GAAGnI,IAAI,CAAC0C,OAAL,CAAaD,GAAb,CAAiB,uBAAjB,CAA1B;;QACA,IAAI0F,iBAAJ,EAAuB;UACnBA,iBAAiB,CAACkF,sBAAlB;QACH,CAFD,MAGK;UACD,OAAOhJ,QAAQ,CAAC2C,KAAT,CAAeiG,IAAf,EAAqBtE,IAArB,CAAP;QACH;MACJ,CARD;IASH,CAVD,EA5GqE,CAuHrE;;IACApD,GAAG,CAACyH,WAAJ,CAAgBJ,KAAhB,EAAuB,0BAAvB,EAAmDvI,QAAQ,IAAI;MAC3D,OAAO,UAAU4I,IAAV,EAAgBtE,IAAhB,EAAsB;QACzB,MAAMR,iBAAiB,GAAGnI,IAAI,CAAC0C,OAAL,CAAaD,GAAb,CAAiB,uBAAjB,CAA1B;;QACA,IAAI0F,iBAAJ,EAAuB;UACnBA,iBAAiB,CAACmF,UAAlB,CAA6B3E,IAAI,CAAC,CAAD,CAAjC;QACH,CAFD,MAGK;UACD,OAAOtE,QAAQ,CAAC2C,KAAT,CAAeiG,IAAf,EAAqBtE,IAArB,CAAP;QACH;MACJ,CARD;IASH,CAVD,EAxHqE,CAmIrE;;IACApD,GAAG,CAACyH,WAAJ,CAAgBJ,KAAhB,EAAuB,gBAAvB,EAAyCvI,QAAQ,IAAI;MACjD,OAAO,UAAU4I,IAAV,EAAgBtE,IAAhB,EAAsB;QACzB,MAAMR,iBAAiB,GAAGnI,IAAI,CAAC0C,OAAL,CAAaD,GAAb,CAAiB,uBAAjB,CAA1B;;QACA,IAAI0F,iBAAJ,EAAuB;UACnBA,iBAAiB,CAACoF,eAAlB;QACH,CAFD,MAGK;UACD,OAAOlJ,QAAQ,CAAC2C,KAAT,CAAeiG,IAAf,EAAqBtE,IAArB,CAAP;QACH;MACJ,CARD;IASH,CAVD,EApIqE,CA+IrE;;IACApD,GAAG,CAACyH,WAAJ,CAAgBJ,KAAhB,EAAuB,eAAvB,EAAwCvI,QAAQ,IAAI;MAChD,OAAO,UAAU4I,IAAV,EAAgBtE,IAAhB,EAAsB;QACzB,MAAMR,iBAAiB,GAAGnI,IAAI,CAAC0C,OAAL,CAAaD,GAAb,CAAiB,uBAAjB,CAA1B;;QACA,IAAI0F,iBAAJ,EAAuB;UACnB,OAAOA,iBAAiB,CAACqF,aAAlB,EAAP;QACH,CAFD,MAGK;UACD,OAAOnJ,QAAQ,CAAC2C,KAAT,CAAeiG,IAAf,EAAqBtE,IAArB,CAAP;QACH;MACJ,CARD;IASH,CAVD;EAWH,CA3JD;AA4JH,CAzQD;AA2QA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA3I,IAAI,CAACqF,YAAL,CAAkB,OAAlB,EAA2B,CAACC,MAAD,EAAStF,IAAT,KAAkB;EACzC,MAAMyN,KAAK,GAAGnI,MAAM,CAACmI,KAArB;;EACA,IAAI,OAAOA,KAAP,KAAiB,WAArB,EAAkC;IAC9B;IACA;IACA;EACH;;EACD,IAAI,OAAOzN,IAAP,KAAgB,WAApB,EAAiC;IAC7B,MAAM,IAAI3B,KAAJ,CAAU,iBAAV,CAAN;EACH;;EACD,MAAM2D,aAAa,GAAGhC,IAAI,CAAC,eAAD,CAA1B;EACA,MAAMkF,gBAAgB,GAAGlF,IAAI,CAAC,kBAAD,CAA7B;;EACA,IAAI,CAACgC,aAAL,EAAoB;IAChB,MAAM,IAAI3D,KAAJ,CAAU,uBAAV,CAAN;EACH;;EACD,IAAIoP,KAAK,CAAC,gBAAD,CAAT,EAA6B;IACzB,MAAM,IAAIpP,KAAJ,CAAU,+CAAV,CAAN;EACH;;EACDoP,KAAK,CAAC,gBAAD,CAAL,GAA0B,IAA1B;EACA,MAAMpC,QAAQ,GAAGrL,IAAI,CAAC0C,OAAtB;EACA,MAAMwD,QAAQ,GAAGmF,QAAQ,CAAClH,IAAT,CAAc,IAAIe,gBAAJ,CAAqB,gBAArB,CAAd,CAAjB;EACA,IAAIwI,QAAQ,GAAG,IAAf;EACA,MAAMC,SAAS,GAAGtC,QAAQ,CAAClH,IAAT,CAAc,IAAInC,aAAJ,EAAd,CAAlB;EACA,MAAM4L,aAAa,GAAG;IAClBC,KAAK,EAAEvI,MAAM,CAACuI,KADI;IAElBC,SAAS,EAAExI,MAAM,CAACwI,SAFA;IAGlBC,MAAM,EAAEzI,MAAM,CAACyI,MAHG;IAIlBC,UAAU,EAAE1I,MAAM,CAAC0I,UAJD;IAKlB/B,QAAQ,EAAE3G,MAAM,CAAC2G,QALC;IAMlBM,EAAE,EAAEjH,MAAM,CAACiH;EANO,CAAtB;;EAQA,SAAS0B,eAAT,CAAyBtF,IAAzB,EAA+BuF,QAA/B,EAAyCC,SAAzC,EAAoD;IAChD,KAAK,IAAIpP,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4J,IAAI,CAAC3J,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;MAClC,IAAIqP,GAAG,GAAGzF,IAAI,CAAC5J,CAAD,CAAd;;MACA,IAAI,OAAOqP,GAAP,KAAe,UAAnB,EAA+B;QAC3B;QACA;QACA;QACA;QACA;QACAzF,IAAI,CAAC5J,CAAD,CAAJ,GAAWqP,GAAG,CAACpP,MAAJ,KAAe,CAAhB,GAAqBkP,QAAQ,CAACE,GAAD,CAA7B,GAAqCD,SAAS,CAACC,GAAD,CAAxD,CAN2B,CAO3B;QACA;;QACAzF,IAAI,CAAC5J,CAAD,CAAJ,CAAQsP,QAAR,GAAmB,YAAY;UAC3B,OAAOD,GAAG,CAACC,QAAJ,EAAP;QACH,CAFD;MAGH;IACJ;;IACD,OAAO1F,IAAP;EACH;;EACD,SAASf,kBAAT,CAA4Be,IAA5B,EAAkC;IAC9B,MAAMuF,QAAQ,GAAG,UAAU7D,EAAV,EAAc;MAC3B,OAAO,YAAY;QACf,OAAOnE,QAAQ,CAACoD,GAAT,CAAae,EAAb,EAAiB,IAAjB,EAAuBpD,SAAvB,CAAP;MACH,CAFD;IAGH,CAJD;;IAKA,OAAOgH,eAAe,CAACtF,IAAD,EAAOuF,QAAP,CAAtB;EACH;;EACD,SAASpG,cAAT,CAAwBa,IAAxB,EAA8B;IAC1B,MAAMwF,SAAS,GAAG,UAAU9D,EAAV,EAAc;MAC5B,OAAO,UAAUX,IAAV,EAAgB;QACnB,OAAOgE,QAAQ,CAACpE,GAAT,CAAae,EAAb,EAAiB,IAAjB,EAAuB,CAACX,IAAD,CAAvB,CAAP;MACH,CAFD;IAGH,CAJD;;IAKA,MAAMwE,QAAQ,GAAG,UAAU7D,EAAV,EAAc;MAC3B,OAAO,YAAY;QACf,OAAOqD,QAAQ,CAACpE,GAAT,CAAae,EAAb,EAAiB,IAAjB,CAAP;MACH,CAFD;IAGH,CAJD;;IAKA,OAAO4D,eAAe,CAACtF,IAAD,EAAOuF,QAAP,EAAiBC,SAAjB,CAAtB;EACH;;EACD,SAASG,eAAT,CAAyB3F,IAAzB,EAA+B;IAC3B,MAAMwF,SAAS,GAAG,UAAU9D,EAAV,EAAc;MAC5B,OAAO,UAAUX,IAAV,EAAgB;QACnB,OAAOiE,SAAS,CAACrE,GAAV,CAAce,EAAd,EAAkB,IAAlB,EAAwB,CAACX,IAAD,CAAxB,CAAP;MACH,CAFD;IAGH,CAJD;;IAKA,MAAMwE,QAAQ,GAAG,UAAU7D,EAAV,EAAc;MAC3B,OAAO,YAAY;QACf,OAAOsD,SAAS,CAACrE,GAAV,CAAce,EAAd,EAAkB,IAAlB,CAAP;MACH,CAFD;IAGH,CAJD;;IAKA,OAAO4D,eAAe,CAACtF,IAAD,EAAOuF,QAAP,EAAiBC,SAAjB,CAAtB;EACH;;EACD7I,MAAM,CAAC2G,QAAP,GAAkB3G,MAAM,CAACiJ,KAAP,GAAe,YAAY;IACzC,OAAOX,aAAa,CAAC3B,QAAd,CAAuBjF,KAAvB,CAA6B,IAA7B,EAAmCY,kBAAkB,CAACX,SAAD,CAArD,CAAP;EACH,CAFD;;EAGA3B,MAAM,CAAC+G,SAAP,GAAmB/G,MAAM,CAACiJ,KAAP,CAAanC,IAAb,GAAoB,YAAY;IAC/C,OAAOwB,aAAa,CAAC3B,QAAd,CAAuBG,IAAvB,CAA4BpF,KAA5B,CAAkC,IAAlC,EAAwCY,kBAAkB,CAACX,SAAD,CAA1D,CAAP;EACH,CAFD;;EAGA3B,MAAM,CAAC2G,QAAP,CAAgBC,IAAhB,GAAuB5G,MAAM,CAACiJ,KAAP,CAAarC,IAAb,GAAoB,YAAY;IACnD,OAAO0B,aAAa,CAAC3B,QAAd,CAAuBC,IAAvB,CAA4BlF,KAA5B,CAAkC,IAAlC,EAAwCY,kBAAkB,CAACX,SAAD,CAA1D,CAAP;EACH,CAFD;;EAGA3B,MAAM,CAACiH,EAAP,GAAYjH,MAAM,CAACkJ,OAAP,GAAiBlJ,MAAM,CAACoH,IAAP,GAAc,YAAY;IACnD,OAAOkB,aAAa,CAACrB,EAAd,CAAiBvF,KAAjB,CAAuB,IAAvB,EAA6Bc,cAAc,CAACb,SAAD,CAA3C,CAAP;EACH,CAFD;;EAGA3B,MAAM,CAACmH,GAAP,GAAanH,MAAM,CAACmJ,QAAP,GAAkB,YAAY;IACvC,OAAOb,aAAa,CAACrB,EAAd,CAAiBH,IAAjB,CAAsBpF,KAAtB,CAA4B,IAA5B,EAAkCc,cAAc,CAACb,SAAD,CAAhD,CAAP;EACH,CAFD;;EAGA3B,MAAM,CAACiH,EAAP,CAAUL,IAAV,GAAiB5G,MAAM,CAACoH,IAAP,CAAYR,IAAZ,GAAmB,YAAY;IAC5C,OAAO0B,aAAa,CAACrB,EAAd,CAAiBL,IAAjB,CAAsBlF,KAAtB,CAA4B,IAA5B,EAAkCc,cAAc,CAACb,SAAD,CAAhD,CAAP;EACH,CAFD;;EAGA3B,MAAM,CAACuI,KAAP,GAAevI,MAAM,CAACoJ,aAAP,GAAuB,YAAY;IAC9C,OAAOd,aAAa,CAACC,KAAd,CAAoB7G,KAApB,CAA0B,IAA1B,EAAgCsH,eAAe,CAACrH,SAAD,CAA/C,CAAP;EACH,CAFD;;EAGA3B,MAAM,CAACwI,SAAP,GAAmBxI,MAAM,CAACqJ,QAAP,GAAkB,YAAY;IAC7C,OAAOf,aAAa,CAACE,SAAd,CAAwB9G,KAAxB,CAA8B,IAA9B,EAAoCc,cAAc,CAACb,SAAD,CAAlD,CAAP;EACH,CAFD;;EAGA3B,MAAM,CAACyI,MAAP,GAAgBzI,MAAM,CAACsJ,UAAP,GAAoB,YAAY;IAC5C,OAAOhB,aAAa,CAACG,MAAd,CAAqB/G,KAArB,CAA2B,IAA3B,EAAiCsH,eAAe,CAACrH,SAAD,CAAhD,CAAP;EACH,CAFD;;EAGA3B,MAAM,CAAC0I,UAAP,GAAoB1I,MAAM,CAACuJ,KAAP,GAAe,YAAY;IAC3C,OAAOjB,aAAa,CAACI,UAAd,CAAyBhH,KAAzB,CAA+B,IAA/B,EAAqCc,cAAc,CAACb,SAAD,CAAnD,CAAP;EACH,CAFD;;EAGA,CAAC,CAAC6H,eAAD,EAAkBC,WAAlB,KAAkC;IAC/BtB,KAAK,CAACuB,MAAN,CAAanJ,SAAb,CAAuBoJ,OAAvB,GAAiC,UAAU5E,EAAV,EAAc;MAC3CrK,IAAI,CAAC0C,OAAL,CAAa4H,iBAAb,CAA+B,iBAA/B,EAAkD,MAAM;QACpDwE,eAAe,CAACnH,IAAhB,CAAqB,IAArB,EAA2B0C,EAA3B;MACH,CAFD;IAGH,CAJD;;IAKAoD,KAAK,CAACuB,MAAN,CAAanJ,SAAb,CAAuByD,GAAvB,GAA6B,UAAUe,EAAV,EAAc;MACvC,KAAKjD,EAAL,CAAQ,MAAR,EAAiB8H,CAAD,IAAO;QACnBxB,QAAQ,GAAGrC,QAAQ,CAAClH,IAAT,CAAc,IAAInC,aAAJ,EAAd,CAAX;MACH,CAFD;MAGA,KAAKoF,EAAL,CAAQ,MAAR,EAAgB,CAACsF,IAAD,EAAOnO,GAAP,KAAe;QAC3B,MAAMwM,aAAa,GAAG2C,QAAQ,IAAIA,QAAQ,CAACjL,GAAT,CAAa,eAAb,CAAlC;;QACA,IAAIsI,aAAa,IAAIxM,GAArB,EAA0B;UACtB,IAAI;YACA;YACAA,GAAG,CAACuM,OAAJ,IAAeC,aAAa,CAACpH,2BAAd,EAAf;UACH,CAHD,CAIA,OAAO3F,KAAP,EAAc,CACb;QACJ;MACJ,CAVD;MAWA,OAAO+Q,WAAW,CAACpH,IAAZ,CAAiB,IAAjB,EAAuB0C,EAAvB,CAAP;IACH,CAhBD;EAiBH,CAvBD,EAuBGoD,KAAK,CAACuB,MAAN,CAAanJ,SAAb,CAAuBoJ,OAvB1B,EAuBmCxB,KAAK,CAACuB,MAAN,CAAanJ,SAAb,CAAuByD,GAvB1D;AAwBH,CA1ID;AA4IA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,CAAC,UAAU6F,OAAV,EAAmB;EAChB,MAAMC,iBAAN,CAAwB;IACpBrR,WAAW,CAACsR,cAAD,EAAiBC,YAAjB,EAA+BnK,UAA/B,EAA2C;MAClD,KAAKkK,cAAL,GAAsBA,cAAtB;MACA,KAAKC,YAAL,GAAoBA,YAApB;MACA,KAAKC,kBAAL,GAA0B,KAA1B;MACA,KAAKC,kBAAL,GAA0B,KAA1B;MACA,KAAKC,eAAL,GAAuB,KAAvB;MACA,KAAKC,OAAL,GAAe,KAAf;MACA,KAAKC,aAAL,GAAqB,IAArB;MACA,KAAKvK,OAAL,GAAepF,IAAI,CAAC0C,OAApB;MACA,KAAKkN,6BAAL,GAAqC,CAArC;MACA,KAAKC,mCAAL,GAA2C,KAA3C;MACA,KAAK5P,IAAL,GAAY,uBAAuBkF,UAAnC;MACA,KAAKhD,UAAL,GAAkB;QAAE,qBAAqB;MAAvB,CAAlB;MACA,KAAK0N,mCAAL,GACIV,OAAO,CAACnP,IAAI,CAACK,UAAL,CAAgB,qCAAhB,CAAD,CAAP,KAAoE,IADxE;IAEH;;IACDyP,iCAAiC,GAAG;MAChC,OAAO,KAAKF,6BAAL,GAAqC,CAA5C;IACH;;IACDG,qBAAqB,GAAG;MACpB,IAAI,EAAE,KAAKR,kBAAL,IAA2B,KAAKC,kBAAhC,IACD,KAAKK,mCAAL,IAA4C,KAAKC,iCAAL,EAD7C,CAAJ,EAC6F;QACzF;QACA,KAAK1K,OAAL,CAAakE,GAAb,CAAiB,MAAM;UACnBmB,UAAU,CAAC,MAAM;YACb,IAAI,CAAC,KAAKgF,eAAN,IAAyB,EAAE,KAAKF,kBAAL,IAA2B,KAAKC,kBAAlC,CAA7B,EAAoF;cAChF,KAAKH,cAAL;YACH;UACJ,CAJS,EAIP,CAJO,CAAV;QAKH,CAND;MAOH;IACJ;;IACDW,mBAAmB,GAAG;MAClB,IAAI,CAAC,KAAKH,mCAAV,EAA+C;QAC3C;MACH;;MACD,MAAMG,mBAAmB,GAAGC,OAAO,CAACjQ,IAAI,CAACK,UAAL,CAAgB,qBAAhB,CAAD,CAAnC;;MACA,IAAI2P,mBAAJ,EAAyB;QACrBA,mBAAmB;MACtB;IACJ;;IACDE,qBAAqB,GAAG;MACpB,IAAI,CAAC,KAAKL,mCAAV,EAA+C;QAC3C;MACH;;MACD,MAAMK,qBAAqB,GAAGD,OAAO,CAACjQ,IAAI,CAACK,UAAL,CAAgB,uBAAhB,CAAD,CAArC;;MACA,IAAI6P,qBAAJ,EAA2B;QACvBA,qBAAqB;MACxB;IACJ;;IACD5P,cAAc,CAAC+D,QAAD,EAAW3B,OAAX,EAAoBqC,MAApB,EAA4BrE,IAA5B,EAAkC;MAC5C,IAAIA,IAAI,CAACI,IAAL,KAAc,WAAlB,EAA+B;QAC3B,KAAK4O,OAAL,GAAe,KAAf;MACH;;MACD,IAAIhP,IAAI,CAACI,IAAL,KAAc,WAAd,IAA6BJ,IAAI,CAACE,IAAlC,IAA0CF,IAAI,CAACE,IAAL,YAAqBqP,OAAnE,EAA4E;QACxE;QACA,IAAIvP,IAAI,CAACE,IAAL,CAAUwO,iBAAiB,CAACe,sBAA5B,MAAwD,IAA5D,EAAkE;UAC9D;UACA,KAAKP,6BAAL;QACH;MACJ;;MACD,OAAOvL,QAAQ,CAACpD,YAAT,CAAsB8D,MAAtB,EAA8BrE,IAA9B,CAAP;IACH;;IACDiE,YAAY,CAACN,QAAD,EAAW3B,OAAX,EAAoBqC,MAApB,EAA4BrE,IAA5B,EAAkC8D,SAAlC,EAA6CC,SAA7C,EAAwD;MAChE,IAAI/D,IAAI,CAACI,IAAL,KAAc,WAAlB,EAA+B;QAC3B,KAAK4O,OAAL,GAAe,KAAf;MACH;;MACD,OAAOrL,QAAQ,CAACO,UAAT,CAAoBG,MAApB,EAA4BrE,IAA5B,EAAkC8D,SAAlC,EAA6CC,SAA7C,CAAP;IACH;;IACDI,YAAY,CAACR,QAAD,EAAW3B,OAAX,EAAoBqC,MAApB,EAA4BrE,IAA5B,EAAkC;MAC1C,IAAIA,IAAI,CAACI,IAAL,KAAc,WAAlB,EAA+B;QAC3B,KAAK4O,OAAL,GAAe,KAAf;MACH;;MACD,OAAOrL,QAAQ,CAACS,UAAT,CAAoBC,MAApB,EAA4BrE,IAA5B,CAAP;IACH,CA3EmB,CA4EpB;IACA;IACA;IACA;IACA;;;IACA6D,QAAQ,CAAChE,kBAAD,EAAqBC,WAArB,EAAkCC,UAAlC,EAA8C4D,QAA9C,EAAwDG,SAAxD,EAAmEC,SAAnE,EAA8EV,MAA9E,EAAsF;MAC1F,IAAI,CAAC,KAAK4L,aAAV,EAAyB;QACrB,KAAKA,aAAL,GAAqBtL,QAArB;MACH;;MACD,IAAI;QACA,KAAKqL,OAAL,GAAe,IAAf;QACA,OAAOnP,kBAAkB,CAACmE,MAAnB,CAA0BjE,UAA1B,EAAsC4D,QAAtC,EAAgDG,SAAhD,EAA2DC,SAA3D,EAAsEV,MAAtE,CAAP;MACH,CAHD,SAIQ;QACJxD,kBAAkB,CAAC6P,WAAnB,CADI,CAEJ;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QACA,IAAI,KAAKV,OAAL,IAAgB,KAAKC,aAAL,KAAuBtL,QAA3C,EAAqD;UACjD,KAAK0L,qBAAL;QACH;MACJ;IACJ;;IACD7O,aAAa,CAACX,kBAAD,EAAqBC,WAArB,EAAkCC,UAAlC,EAA8CzC,KAA9C,EAAqD;MAC9D;MACA,MAAMqS,MAAM,GAAG9P,kBAAkB,CAACc,WAAnB,CAA+BZ,UAA/B,EAA2CzC,KAA3C,CAAf;;MACA,IAAIqS,MAAJ,EAAY;QACR,KAAKf,YAAL,CAAkBtR,KAAlB;QACA,KAAKyR,eAAL,GAAuB,IAAvB;MACH;;MACD,OAAO,KAAP;IACH;;IACDjM,SAAS,CAACa,QAAD,EAAW3B,OAAX,EAAoBqC,MAApB,EAA4BC,YAA5B,EAA0C;MAC/CX,QAAQ,CAACY,OAAT,CAAiBF,MAAjB,EAAyBC,YAAzB,EAD+C,CAE/C;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;MACA,IAAItC,OAAO,KAAKqC,MAAhB,EAAwB;QACpB;MACH;;MACD,IAAIC,YAAY,CAACsL,MAAb,IAAuB,WAA3B,EAAwC;QACpC,KAAKf,kBAAL,GAA0BvK,YAAY,CAAC5B,SAAvC;;QACA,KAAK2M,qBAAL;MACH,CAHD,MAIK,IAAI/K,YAAY,CAACsL,MAAb,IAAuB,WAA3B,EAAwC;QACzC,KAAKd,kBAAL,GAA0BxK,YAAY,CAAC7B,SAAvC;;QACA,KAAK4M,qBAAL;MACH;IACJ;;EA5ImB;;EA8IxBX,iBAAiB,CAACe,sBAAlB,GAA2CnQ,IAAI,CAACK,UAAL,CAAgB,kBAAhB,CAA3C,CA/IgB,CAgJhB;EACA;;EACAL,IAAI,CAAC,mBAAD,CAAJ,GAA4BoP,iBAA5B;AACH,CAnJD,EAmJG,OAAOmB,MAAP,KAAkB,WAAlB,IAAiCA,MAAjC,IAA2C,OAAOtD,IAAP,KAAgB,WAAhB,IAA+BA,IAA1E,IAAkF3H,MAnJrF;;AAoJAtF,IAAI,CAACqF,YAAL,CAAkB,WAAlB,EAA+B,CAACC,MAAD,EAAStF,IAAT,EAAeuF,GAAf,KAAuB;EAClD;AACJ;AACA;AACA;EACIvF,IAAI,CAACuF,GAAG,CAACY,MAAJ,CAAW,WAAX,CAAD,CAAJ,GAAgC,SAASgI,SAAT,CAAmB9D,EAAnB,EAAuB;IACnD;IACA;IACA,IAAI/E,MAAM,CAACU,OAAX,EAAoB;MAChB;MACA,OAAO,UAAU0D,IAAV,EAAgB;QACnB,IAAI,CAACA,IAAL,EAAW;UACP;UACA;UACAA,IAAI,GAAG,YAAY,CAAG,CAAtB;;UACAA,IAAI,CAAC8G,IAAL,GAAY,UAAUtB,CAAV,EAAa;YACrB,MAAMA,CAAN;UACH,CAFD;QAGH;;QACD3F,aAAa,CAACc,EAAD,EAAK,IAAL,EAAWX,IAAX,EAAkBnL,GAAD,IAAS;UACnC,IAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;YACzB,OAAOmL,IAAI,CAAC8G,IAAL,CAAU,IAAInS,KAAJ,CAAUE,GAAV,CAAV,CAAP;UACH,CAFD,MAGK;YACDmL,IAAI,CAAC8G,IAAL,CAAUjS,GAAV;UACH;QACJ,CAPY,CAAb;MAQH,CAjBD;IAkBH,CAvBkD,CAwBnD;IACA;IACA;IACA;;;IACA,OAAO,YAAY;MACf,OAAO,IAAI0R,OAAJ,CAAY,CAACZ,cAAD,EAAiBC,YAAjB,KAAkC;QACjD/F,aAAa,CAACc,EAAD,EAAK,IAAL,EAAWgF,cAAX,EAA2BC,YAA3B,CAAb;MACH,CAFM,CAAP;IAGH,CAJD;EAKH,CAjCD;;EAkCA,SAAS/F,aAAT,CAAuBc,EAAvB,EAA2Be,OAA3B,EAAoCiE,cAApC,EAAoDC,YAApD,EAAkE;IAC9D,MAAM9O,WAAW,GAAGR,IAAI,CAAC0C,OAAzB;IACA,MAAM0M,iBAAiB,GAAGpP,IAAI,CAAC,mBAAD,CAA9B;;IACA,IAAIoP,iBAAiB,KAAKhP,SAA1B,EAAqC;MACjC,MAAM,IAAI/B,KAAJ,CAAU,qFACZ,4EADE,CAAN;IAEH;;IACD,MAAM2D,aAAa,GAAGhC,IAAI,CAAC,eAAD,CAA1B;;IACA,IAAI,CAACgC,aAAL,EAAoB;MAChB,MAAM,IAAI3D,KAAJ,CAAU,iFACZ,uEADE,CAAN;IAEH;;IACD,MAAM0M,aAAa,GAAG/I,aAAa,CAACS,GAAd,EAAtB;IACAT,aAAa,CAACY,aAAd,GAb8D,CAc9D;IACA;;IACA,MAAM0I,SAAS,GAAGtL,IAAI,CAAC0C,OAAL,CAAa+N,WAAb,CAAyB,eAAzB,CAAlB;IACA,MAAMC,gBAAgB,GAAG3F,aAAa,CAAC1H,WAAd,EAAzB;IACAiI,SAAS,CAACH,MAAV,CAAiB7B,GAAjB,CAAqB,MAAM;MACvB,MAAMqH,YAAY,GAAG,IAAIvB,iBAAJ,CAAsB,MAAM;QAC7C;QACA,IAAIrE,aAAa,CAAC1H,WAAd,MAA+BsN,YAAnC,EAAiD;UAC7C;UACA;UACA;UACA5F,aAAa,CAACvI,WAAd,CAA0BkO,gBAA1B;QACH;;QACDC,YAAY,CAACT,qBAAb;QACA1P,WAAW,CAAC8I,GAAZ,CAAgB,MAAM;UAClB+F,cAAc;QACjB,CAFD;MAGH,CAZoB,EAYjBrR,KAAD,IAAW;QACV;QACA,IAAI+M,aAAa,CAAC1H,WAAd,MAA+BsN,YAAnC,EAAiD;UAC7C;UACA5F,aAAa,CAACvI,WAAd,CAA0BkO,gBAA1B;QACH;;QACDC,YAAY,CAACT,qBAAb;QACA1P,WAAW,CAAC8I,GAAZ,CAAgB,MAAM;UAClBgG,YAAY,CAACtR,KAAD,CAAZ;QACH,CAFD;MAGH,CAtBoB,EAsBlB,MAtBkB,CAArB;MAuBA+M,aAAa,CAACvI,WAAd,CAA0BmO,YAA1B;MACAA,YAAY,CAACX,mBAAb;IACH,CA1BD;IA2BA,OAAOhQ,IAAI,CAAC0C,OAAL,CAAakO,UAAb,CAAwBvG,EAAxB,EAA4Be,OAA5B,CAAP;EACH;AACJ,CAtFD;AAwFA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,CAAC,UAAU9F,MAAV,EAAkB;EACf,MAAMuL,YAAY,GAAGvL,MAAM,CAACnH,IAA5B,CADe,CAEf;EACA;EACA;EACA;;EACA,SAAS2S,QAAT,GAAoB;IAChB,IAAI7J,SAAS,CAACjI,MAAV,KAAqB,CAAzB,EAA4B;MACxB,MAAMyG,CAAC,GAAG,IAAIoL,YAAJ,EAAV;MACApL,CAAC,CAACsL,OAAF,CAAUD,QAAQ,CAACE,GAAT,EAAV;MACA,OAAOvL,CAAP;IACH,CAJD,MAKK;MACD,MAAMkD,IAAI,GAAGC,KAAK,CAAC/C,SAAN,CAAgBgD,KAAhB,CAAsBlB,IAAtB,CAA2BV,SAA3B,CAAb;MACA,OAAO,IAAI4J,YAAJ,CAAiB,GAAGlI,IAApB,CAAP;IACH;EACJ;;EACDmI,QAAQ,CAACE,GAAT,GAAe,YAAY;IACvB,MAAMC,qBAAqB,GAAGjR,IAAI,CAAC0C,OAAL,CAAaD,GAAb,CAAiB,uBAAjB,CAA9B;;IACA,IAAIwO,qBAAJ,EAA2B;MACvB,OAAOA,qBAAqB,CAACC,iBAAtB,EAAP;IACH;;IACD,OAAOL,YAAY,CAACG,GAAb,CAAiBhK,KAAjB,CAAuB,IAAvB,EAA6BC,SAA7B,CAAP;EACH,CAND;;EAOA6J,QAAQ,CAACK,GAAT,GAAeN,YAAY,CAACM,GAA5B;EACAL,QAAQ,CAACM,KAAT,GAAiBP,YAAY,CAACO,KAA9B,CAzBe,CA0Bf;;EACA,MAAMC,MAAM,GAAG;IACX5G,UAAU,EAAEnF,MAAM,CAACmF,UADR;IAEX6G,WAAW,EAAEhM,MAAM,CAACgM,WAFT;IAGX5G,YAAY,EAAEpF,MAAM,CAACoF,YAHV;IAIX6G,aAAa,EAAEjM,MAAM,CAACiM;EAJX,CAAf;;EAMA,MAAMC,SAAN,CAAgB;IACZzT,WAAW,GAAG;MACV;MACA,KAAK0T,eAAL,GAAuB,EAAvB,CAFU,CAGV;;MACA,KAAKC,gBAAL,GAAwB,CAAxB,CAJU,CAKV;;MACA,KAAKC,0BAAL,GAAkCd,YAAY,CAACG,GAAb,EAAlC,CANU,CAOV;;MACA,KAAKY,kCAAL,GAA0C,EAA1C;IACH;;IACDC,kBAAkB,GAAG;MACjB,OAAO,KAAKH,gBAAZ;IACH;;IACDR,iBAAiB,GAAG;MAChB,OAAO,KAAKS,0BAAL,GAAkC,KAAKD,gBAA9C;IACH;;IACDnJ,qBAAqB,CAACuJ,kBAAD,EAAqB;MACtC,KAAKH,0BAAL,GAAkCG,kBAAlC;IACH;;IACD5E,iBAAiB,GAAG;MAChB,OAAO2D,YAAY,CAACG,GAAb,EAAP;IACH;;IACDe,gBAAgB,CAACC,EAAD,EAAKC,KAAL,EAAYC,OAAZ,EAAqB;MACjCA,OAAO,GAAGnR,MAAM,CAACC,MAAP,CAAc;QACpB2H,IAAI,EAAE,EADc;QAEpBwJ,UAAU,EAAE,KAFQ;QAGpBC,uBAAuB,EAAE,KAHL;QAIpBC,EAAE,EAAE,CAAC,CAJe;QAKpBC,iBAAiB,EAAE;MALC,CAAd,EAMPJ,OANO,CAAV;MAOA,IAAIK,SAAS,GAAGL,OAAO,CAACG,EAAR,GAAa,CAAb,GAAiBb,SAAS,CAACgB,MAAV,EAAjB,GAAsCN,OAAO,CAACG,EAA9D;MACA,IAAII,OAAO,GAAG,KAAKf,gBAAL,GAAwBO,KAAtC,CATiC,CAUjC;;MACA,IAAIS,QAAQ,GAAG;QACXD,OAAO,EAAEA,OADE;QAEXJ,EAAE,EAAEE,SAFO;QAGXI,IAAI,EAAEX,EAHK;QAIXrJ,IAAI,EAAEuJ,OAAO,CAACvJ,IAJH;QAKXsJ,KAAK,EAAEA,KALI;QAMXE,UAAU,EAAED,OAAO,CAACC,UANT;QAOXC,uBAAuB,EAAEF,OAAO,CAACE;MAPtB,CAAf;;MASA,IAAIF,OAAO,CAACI,iBAAZ,EAA+B;QAC3B,KAAKV,kCAAL,CAAwCzS,IAAxC,CAA6CuT,QAA7C;MACH;;MACD,IAAI3T,CAAC,GAAG,CAAR;;MACA,OAAOA,CAAC,GAAG,KAAK0S,eAAL,CAAqBzS,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;QACzC,IAAI6T,YAAY,GAAG,KAAKnB,eAAL,CAAqB1S,CAArB,CAAnB;;QACA,IAAI2T,QAAQ,CAACD,OAAT,GAAmBG,YAAY,CAACH,OAApC,EAA6C;UACzC;QACH;MACJ;;MACD,KAAKhB,eAAL,CAAqB/N,MAArB,CAA4B3E,CAA5B,EAA+B,CAA/B,EAAkC2T,QAAlC;;MACA,OAAOH,SAAP;IACH;;IACDM,6BAA6B,CAACR,EAAD,EAAK;MAC9B,KAAK,IAAItT,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK0S,eAAL,CAAqBzS,MAAzC,EAAiDD,CAAC,EAAlD,EAAsD;QAClD,IAAI,KAAK0S,eAAL,CAAqB1S,CAArB,EAAwBsT,EAAxB,IAA8BA,EAAlC,EAAsC;UAClC,KAAKZ,eAAL,CAAqB/N,MAArB,CAA4B3E,CAA5B,EAA+B,CAA/B;;UACA;QACH;MACJ;IACJ;;IACD+T,SAAS,GAAG;MACR,KAAKrB,eAAL,GAAuB,EAAvB;IACH;;IACDjE,aAAa,GAAG;MACZ,OAAO,KAAKiE,eAAL,CAAqBzS,MAA5B;IACH;;IACDsO,UAAU,CAACyF,IAAI,GAAG,CAAR,EAAWC,MAAX,EAAmBC,WAAnB,EAAgC;MACtC,IAAI,KAAKxB,eAAL,CAAqBzS,MAArB,GAA8B+T,IAAlC,EAAwC;QACpC;MACH,CAHqC,CAItC;MACA;;;MACA,MAAMG,SAAS,GAAG,KAAKxB,gBAAvB;MACA,MAAMyB,UAAU,GAAG,KAAK1B,eAAL,CAAqBsB,IAAI,GAAG,CAA5B,CAAnB;MACA,KAAK7K,IAAL,CAAUiL,UAAU,CAACV,OAAX,GAAqBS,SAA/B,EAA0CF,MAA1C,EAAkDC,WAAlD;IACH;;IACD/K,IAAI,CAACkL,MAAM,GAAG,CAAV,EAAaJ,MAAb,EAAqBC,WAArB,EAAkC;MAClC,IAAII,SAAS,GAAG,KAAK3B,gBAAL,GAAwB0B,MAAxC;MACA,IAAIE,eAAe,GAAG,CAAtB;MACAL,WAAW,GAAGlS,MAAM,CAACC,MAAP,CAAc;QAAEuS,iCAAiC,EAAE;MAArC,CAAd,EAA2DN,WAA3D,CAAd,CAHkC,CAIlC;MACA;MACA;;MACA,MAAMO,cAAc,GAAGP,WAAW,CAACM,iCAAZ,GACnB,KAAK9B,eADc,GAEnB,KAAKA,eAAL,CAAqB5I,KAArB,EAFJ;;MAGA,IAAI2K,cAAc,CAACxU,MAAf,KAA0B,CAA1B,IAA+BgU,MAAnC,EAA2C;QACvCA,MAAM,CAACI,MAAD,CAAN;QACA;MACH;;MACD,OAAOI,cAAc,CAACxU,MAAf,GAAwB,CAA/B,EAAkC;QAC9B;QACA,KAAK4S,kCAAL,GAA0C,EAA1C;QACA,IAAIlP,OAAO,GAAG8Q,cAAc,CAAC,CAAD,CAA5B;;QACA,IAAIH,SAAS,GAAG3Q,OAAO,CAAC+P,OAAxB,EAAiC;UAC7B;UACA;QACH,CAHD,MAIK;UACD;UACA,IAAI/P,OAAO,GAAG8Q,cAAc,CAACC,KAAf,EAAd;;UACA,IAAI,CAACR,WAAW,CAACM,iCAAjB,EAAoD;YAChD,MAAMG,GAAG,GAAG,KAAKjC,eAAL,CAAqB5P,OAArB,CAA6Ba,OAA7B,CAAZ;;YACA,IAAIgR,GAAG,IAAI,CAAX,EAAc;cACV,KAAKjC,eAAL,CAAqB/N,MAArB,CAA4BgQ,GAA5B,EAAiC,CAAjC;YACH;UACJ;;UACDJ,eAAe,GAAG,KAAK5B,gBAAvB;UACA,KAAKA,gBAAL,GAAwBhP,OAAO,CAAC+P,OAAhC;;UACA,IAAIO,MAAJ,EAAY;YACRA,MAAM,CAAC,KAAKtB,gBAAL,GAAwB4B,eAAzB,CAAN;UACH;;UACD,IAAIK,MAAM,GAAGjR,OAAO,CAACiQ,IAAR,CAAa3L,KAAb,CAAmB1B,MAAnB,EAA2B5C,OAAO,CAAC0P,uBAAR,GAAkC,CAAC,KAAKV,gBAAN,CAAlC,GAA4DhP,OAAO,CAACiG,IAA/F,CAAb;;UACA,IAAI,CAACgL,MAAL,EAAa;YACT;YACA;UACH,CAlBA,CAmBD;UACA;;;UACA,IAAI,CAACV,WAAW,CAACM,iCAAjB,EAAoD;YAChD,KAAK3B,kCAAL,CAAwC7O,OAAxC,CAAgD2P,QAAQ,IAAI;cACxD,IAAI3T,CAAC,GAAG,CAAR;;cACA,OAAOA,CAAC,GAAGyU,cAAc,CAACxU,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;gBACnC,MAAM6T,YAAY,GAAGY,cAAc,CAACzU,CAAD,CAAnC;;gBACA,IAAI2T,QAAQ,CAACD,OAAT,GAAmBG,YAAY,CAACH,OAApC,EAA6C;kBACzC;gBACH;cACJ;;cACDe,cAAc,CAAC9P,MAAf,CAAsB3E,CAAtB,EAAyB,CAAzB,EAA4B2T,QAA5B;YACH,CATD;UAUH;QACJ;MACJ;;MACDY,eAAe,GAAG,KAAK5B,gBAAvB;MACA,KAAKA,gBAAL,GAAwB2B,SAAxB;;MACA,IAAIL,MAAJ,EAAY;QACRA,MAAM,CAAC,KAAKtB,gBAAL,GAAwB4B,eAAzB,CAAN;MACH;IACJ;;IACDjG,sBAAsB,CAAC2F,MAAD,EAAS;MAC3B,IAAI,KAAKvB,eAAL,CAAqBzS,MAArB,KAAgC,CAApC,EAAuC;QACnC,OAAO,CAAP;MACH,CAH0B,CAI3B;MACA;;;MACA,MAAMkU,SAAS,GAAG,KAAKxB,gBAAvB;MACA,MAAMkC,QAAQ,GAAG,KAAKnC,eAAL,CAAqB,KAAKA,eAAL,CAAqBzS,MAArB,GAA8B,CAAnD,CAAjB;MACA,KAAKkJ,IAAL,CAAU0L,QAAQ,CAACnB,OAAT,GAAmBS,SAA7B,EAAwCF,MAAxC,EAAgD;QAAEO,iCAAiC,EAAE;MAArC,CAAhD;MACA,OAAO,KAAK7B,gBAAL,GAAwBwB,SAA/B;IACH;;IACD9F,KAAK,CAACyG,KAAK,GAAG,EAAT,EAAaC,aAAa,GAAG,KAA7B,EAAoCd,MAApC,EAA4C;MAC7C,IAAIc,aAAJ,EAAmB;QACf,OAAO,KAAKA,aAAL,CAAmBd,MAAnB,CAAP;MACH,CAFD,MAGK;QACD,OAAO,KAAKe,gBAAL,CAAsBF,KAAtB,EAA6Bb,MAA7B,CAAP;MACH;IACJ;;IACDc,aAAa,CAACd,MAAD,EAAS;MAClB,IAAI,KAAKvB,eAAL,CAAqBzS,MAArB,KAAgC,CAApC,EAAuC;QACnC,OAAO,CAAP;MACH,CAHiB,CAIlB;MACA;;;MACA,MAAMkU,SAAS,GAAG,KAAKxB,gBAAvB;MACA,MAAMkC,QAAQ,GAAG,KAAKnC,eAAL,CAAqB,KAAKA,eAAL,CAAqBzS,MAArB,GAA8B,CAAnD,CAAjB;MACA,KAAKkJ,IAAL,CAAU0L,QAAQ,CAACnB,OAAT,GAAmBS,SAA7B,EAAwCF,MAAxC;MACA,OAAO,KAAKtB,gBAAL,GAAwBwB,SAA/B;IACH;;IACDa,gBAAgB,CAACF,KAAD,EAAQb,MAAR,EAAgB;MAC5B,MAAME,SAAS,GAAG,KAAKxB,gBAAvB;MACA,IAAI4B,eAAe,GAAG,CAAtB;MACA,IAAI9R,KAAK,GAAG,CAAZ;;MACA,OAAO,KAAKiQ,eAAL,CAAqBzS,MAArB,GAA8B,CAArC,EAAwC;QACpCwC,KAAK;;QACL,IAAIA,KAAK,GAAGqS,KAAZ,EAAmB;UACf,MAAM,IAAIxV,KAAJ,CAAU,8CAA8CwV,KAA9C,GACZ,+CADE,CAAN;QAEH,CALmC,CAMpC;QACA;;;QACA,IAAI,KAAKpC,eAAL,CAAqBuC,MAArB,CAA4BtT,IAAI,IAAI,CAACA,IAAI,CAACyR,UAAN,IAAoB,CAACzR,IAAI,CAAC0R,uBAA9D,EACCpT,MADD,KACY,CADhB,EACmB;UACf;QACH;;QACD,MAAM0D,OAAO,GAAG,KAAK+O,eAAL,CAAqBgC,KAArB,EAAhB;;QACAH,eAAe,GAAG,KAAK5B,gBAAvB;QACA,KAAKA,gBAAL,GAAwBhP,OAAO,CAAC+P,OAAhC;;QACA,IAAIO,MAAJ,EAAY;UACR;UACAA,MAAM,CAAC,KAAKtB,gBAAL,GAAwB4B,eAAzB,CAAN;QACH;;QACD,MAAMK,MAAM,GAAGjR,OAAO,CAACiQ,IAAR,CAAa3L,KAAb,CAAmB1B,MAAnB,EAA2B5C,OAAO,CAACiG,IAAnC,CAAf;;QACA,IAAI,CAACgL,MAAL,EAAa;UACT;UACA;QACH;MACJ;;MACD,OAAO,KAAKjC,gBAAL,GAAwBwB,SAA/B;IACH;;EA3MW,CAjCD,CA8Of;;;EACA1B,SAAS,CAACgB,MAAV,GAAmB,CAAnB;;EACA,MAAMhK,qBAAN,CAA4B;IACxBzK,WAAW,CAACoH,UAAD,EAAa8O,iCAAiC,GAAG,KAAjD,EAAwDC,gBAAxD,EAA0E;MACjF,KAAKD,iCAAL,GAAyCA,iCAAzC;MACA,KAAKC,gBAAL,GAAwBA,gBAAxB;MACA,KAAKC,UAAL,GAAkB,IAAI3C,SAAJ,EAAlB;MACA,KAAK4C,WAAL,GAAmB,EAAnB;MACA,KAAKC,UAAL,GAAkB,IAAlB;MACA,KAAKC,sBAAL,GAA8BrE,OAAO,CAACjQ,IAAI,CAACK,UAAL,CAAgB,uBAAhB,CAAD,CAArC;MACA,KAAKkU,qBAAL,GAA6B,EAA7B;MACA,KAAKC,aAAL,GAAqB,EAArB;MACA,KAAKC,eAAL,GAAuB,KAAvB;MACA,KAAKtS,UAAL,GAAkB;QAAE,yBAAyB;MAA3B,CAAlB;MACA,KAAKlC,IAAL,GAAY,2BAA2BkF,UAAvC,CAXiF,CAYjF;MACA;;MACA,IAAI,CAAC,KAAK+O,gBAAV,EAA4B;QACxB,KAAKA,gBAAL,GAAwB5O,MAAM,CAACtF,IAAI,CAACK,UAAL,CAAgB,wBAAhB,CAAD,CAA9B;MACH;IACJ;;IACkB,OAAZqU,YAAY,GAAG;MAClB,IAAI1U,IAAI,CAAC0C,OAAL,CAAaD,GAAb,CAAiB,uBAAjB,KAA6C,IAAjD,EAAuD;QACnD,MAAM,IAAIpE,KAAJ,CAAU,wEAAV,CAAN;MACH;IACJ;;IACDsW,WAAW,CAACtK,EAAD,EAAKuK,UAAL,EAAiB;MACxB,OAAO,CAAC,GAAGjM,IAAJ,KAAa;QAChB0B,EAAE,CAACrD,KAAH,CAAS1B,MAAT,EAAiBqD,IAAjB;;QACA,IAAI,KAAK0L,UAAL,KAAoB,IAAxB,EAA8B;UAAE;UAC5B,IAAIO,UAAU,CAACC,SAAX,IAAwB,IAA5B,EAAkC;YAC9BD,UAAU,CAACC,SAAX,CAAqB7N,KAArB,CAA2B1B,MAA3B;UACH,CAHyB,CAI1B;;;UACA,KAAK6H,eAAL;QACH,CAND,MAOK;UAAE;UACH,IAAIyH,UAAU,CAACE,OAAX,IAAsB,IAA1B,EAAgC;YAC5BF,UAAU,CAACE,OAAX,CAAmB9N,KAAnB,CAAyB1B,MAAzB;UACH;QACJ,CAbe,CAchB;;;QACA,OAAO,KAAK+O,UAAL,KAAoB,IAA3B;MACH,CAhBD;IAiBH;;IACkB,OAAZU,YAAY,CAAC1D,MAAD,EAASgB,EAAT,EAAa;MAC5B,IAAI2C,KAAK,GAAG3D,MAAM,CAACxP,OAAP,CAAewQ,EAAf,CAAZ;;MACA,IAAI2C,KAAK,GAAG,CAAC,CAAb,EAAgB;QACZ3D,MAAM,CAAC3N,MAAP,CAAcsR,KAAd,EAAqB,CAArB;MACH;IACJ;;IACDC,aAAa,CAAC5C,EAAD,EAAK;MACd,OAAO,MAAM;QACT7J,qBAAqB,CAACuM,YAAtB,CAAmC,KAAKP,aAAxC,EAAuDnC,EAAvD;MACH,CAFD;IAGH;;IACD6C,qBAAqB,CAAC7K,EAAD,EAAK8K,QAAL,EAAexM,IAAf,EAAqB0J,EAArB,EAAyB;MAC1C,OAAO,MAAM;QACT;QACA,IAAI,KAAKkC,qBAAL,CAA2B1S,OAA3B,CAAmCwQ,EAAnC,MAA2C,CAAC,CAAhD,EAAmD;UAC/C,KAAK8B,UAAL,CAAgBpC,gBAAhB,CAAiC1H,EAAjC,EAAqC8K,QAArC,EAA+C;YAAExM,IAAF;YAAQwJ,UAAU,EAAE,IAApB;YAA0BE,EAA1B;YAA8BC,iBAAiB,EAAE;UAAjD,CAA/C;QACH;MACJ,CALD;IAMH;;IACD8C,qBAAqB,CAAC/C,EAAD,EAAK;MACtB,OAAO,MAAM;QACT7J,qBAAqB,CAACuM,YAAtB,CAAmC,KAAKR,qBAAxC,EAA+DlC,EAA/D;MACH,CAFD;IAGH;;IACDgD,WAAW,CAAChL,EAAD,EAAK4H,KAAL,EAAYtJ,IAAZ,EAAkB2M,OAAO,GAAG,IAA5B,EAAkC;MACzC,IAAIC,aAAa,GAAG,KAAKN,aAAL,CAAmBzD,SAAS,CAACgB,MAA7B,CAApB,CADyC,CAEzC;;;MACA,IAAIR,EAAE,GAAG,KAAK2C,WAAL,CAAiBtK,EAAjB,EAAqB;QAAEwK,SAAS,EAAEU,aAAb;QAA4BT,OAAO,EAAES;MAArC,CAArB,CAAT;;MACA,IAAIlD,EAAE,GAAG,KAAK8B,UAAL,CAAgBpC,gBAAhB,CAAiCC,EAAjC,EAAqCC,KAArC,EAA4C;QAAEtJ,IAAF;QAAQyJ,uBAAuB,EAAE,CAACkD;MAAlC,CAA5C,CAAT;;MACA,IAAIA,OAAJ,EAAa;QACT,KAAKd,aAAL,CAAmBrV,IAAnB,CAAwBkT,EAAxB;MACH;;MACD,OAAOA,EAAP;IACH;;IACDmD,aAAa,CAACnD,EAAD,EAAK;MACd7J,qBAAqB,CAACuM,YAAtB,CAAmC,KAAKP,aAAxC,EAAuDnC,EAAvD;;MACA,KAAK8B,UAAL,CAAgBtB,6BAAhB,CAA8CR,EAA9C;IACH;;IACDoD,YAAY,CAACpL,EAAD,EAAK8K,QAAL,EAAexM,IAAf,EAAqB;MAC7B,IAAI0J,EAAE,GAAGb,SAAS,CAACgB,MAAnB;MACA,IAAIoC,UAAU,GAAG;QAAEC,SAAS,EAAE,IAAb;QAAmBC,OAAO,EAAE,KAAKM,qBAAL,CAA2B/C,EAA3B;MAA5B,CAAjB;;MACA,IAAIL,EAAE,GAAG,KAAK2C,WAAL,CAAiBtK,EAAjB,EAAqBuK,UAArB,CAAT,CAH6B,CAI7B;;;MACAA,UAAU,CAACC,SAAX,GAAuB,KAAKK,qBAAL,CAA2BlD,EAA3B,EAA+BmD,QAA/B,EAAyCxM,IAAzC,EAA+C0J,EAA/C,CAAvB,CAL6B,CAM7B;;MACA,KAAK8B,UAAL,CAAgBpC,gBAAhB,CAAiCC,EAAjC,EAAqCmD,QAArC,EAA+C;QAAExM,IAAF;QAAQwJ,UAAU,EAAE;MAApB,CAA/C;;MACA,KAAKoC,qBAAL,CAA2BpV,IAA3B,CAAgCkT,EAAhC;MACA,OAAOA,EAAP;IACH;;IACDqD,cAAc,CAACrD,EAAD,EAAK;MACf7J,qBAAqB,CAACuM,YAAtB,CAAmC,KAAKR,qBAAxC,EAA+DlC,EAA/D;;MACA,KAAK8B,UAAL,CAAgBtB,6BAAhB,CAA8CR,EAA9C;IACH;;IACDsD,uBAAuB,GAAG;MACtB,IAAI3X,KAAK,GAAG,KAAKqW,UAAL,IAAmB,KAAKC,sBAAL,CAA4B,CAA5B,CAA/B;MACA,KAAKA,sBAAL,CAA4BtV,MAA5B,GAAqC,CAArC;MACA,KAAKqV,UAAL,GAAkB,IAAlB;MACA,MAAMrW,KAAN;IACH;;IACD6T,kBAAkB,GAAG;MACjB,OAAO,KAAKsC,UAAL,CAAgBtC,kBAAhB,EAAP;IACH;;IACDX,iBAAiB,GAAG;MAChB,OAAO,KAAKiD,UAAL,CAAgBjD,iBAAhB,EAAP;IACH;;IACD3I,qBAAqB,CAACqN,QAAD,EAAW;MAC5B,KAAKzB,UAAL,CAAgB5L,qBAAhB,CAAsCqN,QAAtC;IACH;;IACD1I,iBAAiB,GAAG;MAChB,OAAO,KAAKiH,UAAL,CAAgBjH,iBAAhB,EAAP;IACH;;IACe,OAAT2I,SAAS,GAAG;MACf,IAAI,CAAC,CAACvQ,MAAM,CAACtF,IAAI,CAACK,UAAL,CAAgB,qBAAhB,CAAD,CAAZ,EAAsD;QAClD;QACA;QACA;QACA;QACA;QACA;MACH;;MACD,IAAIiF,MAAM,CAAC,MAAD,CAAN,KAAmBwL,QAAvB,EAAiC;QAC7B;QACA;MACH;;MACDxL,MAAM,CAAC,MAAD,CAAN,GAAiBwL,QAAjB;MACAA,QAAQ,CAACjL,SAAT,GAAqBgL,YAAY,CAAChL,SAAlC,CAde,CAef;MACA;MACA;;MACA2C,qBAAqB,CAACsN,eAAtB;IACH;;IACe,OAATC,SAAS,GAAG;MACf,IAAIzQ,MAAM,CAAC,MAAD,CAAN,KAAmBwL,QAAvB,EAAiC;QAC7BxL,MAAM,CAAC,MAAD,CAAN,GAAiBuL,YAAjB;MACH;IACJ;;IACqB,OAAfiF,eAAe,GAAG;MACrB,IAAIxQ,MAAM,CAACmF,UAAP,KAAsB4G,MAAM,CAAC5G,UAAjC,EAA6C;QACzCnF,MAAM,CAACmF,UAAP,GAAoB4G,MAAM,CAAC5G,UAA3B;QACAnF,MAAM,CAACoF,YAAP,GAAsB2G,MAAM,CAAC3G,YAA7B;MACH;;MACD,IAAIpF,MAAM,CAACgM,WAAP,KAAuBD,MAAM,CAACC,WAAlC,EAA+C;QAC3ChM,MAAM,CAACgM,WAAP,GAAqBD,MAAM,CAACC,WAA5B;QACAhM,MAAM,CAACiM,aAAP,GAAuBF,MAAM,CAACE,aAA9B;MACH;IACJ;;IACDyE,aAAa,GAAG;MACZ,KAAKvB,eAAL,GAAuB,IAAvB;MACAjM,qBAAqB,CAACqN,SAAtB;IACH;;IACDI,eAAe,GAAG;MACd,KAAKxB,eAAL,GAAuB,KAAvB;MACAjM,qBAAqB,CAACuN,SAAtB;IACH;;IACDzI,UAAU,CAAC4I,KAAK,GAAG,CAAT,EAAYlD,MAAZ,EAAoBC,WAAW,GAAG;MAAEM,iCAAiC,EAAE;IAArC,CAAlC,EAA+E;MACrF,IAAI2C,KAAK,IAAI,CAAb,EAAgB;QACZ;MACH;;MACD1N,qBAAqB,CAACkM,YAAtB;MACA,KAAKvH,eAAL;;MACA,KAAKgH,UAAL,CAAgB7G,UAAhB,CAA2B4I,KAA3B,EAAkClD,MAAlC,EAA0CC,WAA1C;;MACA,IAAI,KAAKoB,UAAL,KAAoB,IAAxB,EAA8B;QAC1B,KAAKsB,uBAAL;MACH;IACJ;;IACDzN,IAAI,CAACkL,MAAM,GAAG,CAAV,EAAaJ,MAAb,EAAqBC,WAAW,GAAG;MAAEM,iCAAiC,EAAE;IAArC,CAAnC,EAAgF;MAChF/K,qBAAqB,CAACkM,YAAtB;MACA,KAAKvH,eAAL;;MACA,KAAKgH,UAAL,CAAgBjM,IAAhB,CAAqBkL,MAArB,EAA6BJ,MAA7B,EAAqCC,WAArC;;MACA,IAAI,KAAKoB,UAAL,KAAoB,IAAxB,EAA8B;QAC1B,KAAKsB,uBAAL;MACH;IACJ;;IACDxI,eAAe,GAAG;MACd3E,qBAAqB,CAACkM,YAAtB;;MACA,MAAMyB,WAAW,GAAG,MAAM;QACtB,IAAI,KAAK9B,UAAL,KAAoB,IAApB,IAA4B,KAAKC,sBAAL,CAA4BtV,MAA5D,EAAoE;UAChE;UACA,KAAK2W,uBAAL;QACH;MACJ,CALD;;MAMA,OAAO,KAAKvB,WAAL,CAAiBpV,MAAjB,GAA0B,CAAjC,EAAoC;QAChC,IAAIoX,SAAS,GAAG,KAAKhC,WAAL,CAAiBX,KAAjB,EAAhB;;QACA2C,SAAS,CAACzD,IAAV,CAAe3L,KAAf,CAAqBoP,SAAS,CAACrR,MAA/B,EAAuCqR,SAAS,CAACzN,IAAjD;MACH;;MACDwN,WAAW;IACd;;IACD/I,KAAK,CAACyG,KAAD,EAAQC,aAAR,EAAuBd,MAAvB,EAA+B;MAChCxK,qBAAqB,CAACkM,YAAtB;MACA,KAAKvH,eAAL;;MACA,MAAMkJ,OAAO,GAAG,KAAKlC,UAAL,CAAgB/G,KAAhB,CAAsByG,KAAtB,EAA6BC,aAA7B,EAA4Cd,MAA5C,CAAhB;;MACA,IAAI,KAAKqB,UAAL,KAAoB,IAAxB,EAA8B;QAC1B,KAAKsB,uBAAL;MACH;;MACD,OAAOU,OAAP;IACH;;IACDhJ,sBAAsB,CAAC2F,MAAD,EAAS;MAC3BxK,qBAAqB,CAACkM,YAAtB;MACA,KAAKvH,eAAL;;MACA,MAAMkJ,OAAO,GAAG,KAAKlC,UAAL,CAAgB9G,sBAAhB,CAAuC2F,MAAvC,CAAhB;;MACA,IAAI,KAAKqB,UAAL,KAAoB,IAAxB,EAA8B;QAC1B,KAAKsB,uBAAL;MACH;;MACD,OAAOU,OAAP;IACH;;IACD9I,eAAe,GAAG;MACd/E,qBAAqB,CAACkM,YAAtB;;MACA,KAAKP,UAAL,CAAgBrB,SAAhB;;MACA,KAAKyB,qBAAL,GAA6B,EAA7B;MACA,KAAKC,aAAL,GAAqB,EAArB;IACH;;IACDhH,aAAa,GAAG;MACZ,OAAO,KAAK2G,UAAL,CAAgB3G,aAAhB,KAAkC,KAAK4G,WAAL,CAAiBpV,MAA1D;IACH;;IACDsB,cAAc,CAAC+D,QAAD,EAAW3B,OAAX,EAAoBqC,MAApB,EAA4BrE,IAA5B,EAAkC;MAC5C,QAAQA,IAAI,CAACI,IAAb;QACI,KAAK,WAAL;UACI,IAAI6H,IAAI,GAAGjI,IAAI,CAACE,IAAL,IAAaF,IAAI,CAACE,IAAL,CAAU+H,IAAlC,CADJ,CAEI;UACA;UACA;;UACA,IAAI2N,cAAJ;;UACA,IAAI3N,IAAJ,EAAU;YACN,IAAI4N,aAAa,GAAG7V,IAAI,CAACE,IAAL,CAAU4V,KAA9B;;YACA,IAAI,OAAO7N,IAAI,CAAC3J,MAAZ,KAAuB,QAAvB,IAAmC2J,IAAI,CAAC3J,MAAL,GAAcuX,aAAa,GAAG,CAArE,EAAwE;cACpED,cAAc,GAAG1N,KAAK,CAAC/C,SAAN,CAAgBgD,KAAhB,CAAsBlB,IAAtB,CAA2BgB,IAA3B,EAAiC4N,aAAa,GAAG,CAAjD,CAAjB;YACH;UACJ;;UACD,KAAKnC,WAAL,CAAiBjV,IAAjB,CAAsB;YAClBwT,IAAI,EAAEjS,IAAI,CAACgE,MADO;YAElBiE,IAAI,EAAE2N,cAFY;YAGlBvR,MAAM,EAAErE,IAAI,CAACE,IAAL,IAAaF,IAAI,CAACE,IAAL,CAAUmE;UAHb,CAAtB;;UAKA;;QACJ,KAAK,WAAL;UACI,QAAQrE,IAAI,CAACqD,MAAb;YACI,KAAK,YAAL;cACIrD,IAAI,CAACE,IAAL,CAAU,UAAV,IAAwB,KAAKyU,WAAL,CAAiB3U,IAAI,CAACgE,MAAtB,EAA8BhE,IAAI,CAACE,IAAL,CAAU,OAAV,CAA9B,EAAkDgI,KAAK,CAAC/C,SAAN,CAAgBgD,KAAhB,CAAsBlB,IAAtB,CAA2BjH,IAAI,CAACE,IAAL,CAAU,MAAV,CAA3B,EAA8C,CAA9C,CAAlD,CAAxB;cACA;;YACJ,KAAK,cAAL;cACIF,IAAI,CAACE,IAAL,CAAU,UAAV,IAAwB,KAAKyU,WAAL,CAAiB3U,IAAI,CAACgE,MAAtB,EAA8B,CAA9B,EAAiCkE,KAAK,CAAC/C,SAAN,CAAgBgD,KAAhB,CAAsBlB,IAAtB,CAA2BjH,IAAI,CAACE,IAAL,CAAU,MAAV,CAA3B,EAA8C,CAA9C,CAAjC,CAAxB;cACA;;YACJ,KAAK,aAAL;cACIF,IAAI,CAACE,IAAL,CAAU,UAAV,IAAwB,KAAK6U,YAAL,CAAkB/U,IAAI,CAACgE,MAAvB,EAA+BhE,IAAI,CAACE,IAAL,CAAU,OAAV,CAA/B,EAAmDgI,KAAK,CAAC/C,SAAN,CAAgBgD,KAAhB,CAAsBlB,IAAtB,CAA2BjH,IAAI,CAACE,IAAL,CAAU,MAAV,CAA3B,EAA8C,CAA9C,CAAnD,CAAxB;cACA;;YACJ,KAAK,qBAAL;cACI,MAAM,IAAIvC,KAAJ,CAAU,kEACZqC,IAAI,CAACE,IAAL,CAAU,KAAV,CADE,CAAN;;YAEJ,KAAK,uBAAL;YACA,KAAK,6BAAL;YACA,KAAK,0BAAL;cACI;cACA;cACAF,IAAI,CAACE,IAAL,CAAU,UAAV,IAAwB,KAAKyU,WAAL,CAAiB3U,IAAI,CAACgE,MAAtB,EAA8B,EAA9B,EAAkChE,IAAI,CAACE,IAAL,CAAU,MAAV,CAAlC,EAAqD,KAAKqT,iCAA1D,CAAxB;cACA;;YACJ;cACI;cACA;cACA,MAAMwC,eAAe,GAAG,KAAKC,mBAAL,CAAyBhW,IAAzB,CAAxB;;cACA,IAAI+V,eAAJ,EAAqB;gBACjB,MAAM9N,IAAI,GAAGjI,IAAI,CAACE,IAAL,IAAaF,IAAI,CAACE,IAAL,CAAU,MAAV,CAA1B;gBACA,MAAMqR,KAAK,GAAGtJ,IAAI,IAAIA,IAAI,CAAC3J,MAAL,GAAc,CAAtB,GAA0B2J,IAAI,CAAC,CAAD,CAA9B,GAAoC,CAAlD;gBACA,IAAIgO,YAAY,GAAGF,eAAe,CAACE,YAAhB,GAA+BF,eAAe,CAACE,YAA/C,GAA8DhO,IAAjF;;gBACA,IAAI,CAAC,CAAC8N,eAAe,CAACtE,UAAtB,EAAkC;kBAC9B;kBACAzR,IAAI,CAACE,IAAL,CAAU,UAAV,IAAwB,KAAK6U,YAAL,CAAkB/U,IAAI,CAACgE,MAAvB,EAA+BuN,KAA/B,EAAsC0E,YAAtC,CAAxB;kBACAjW,IAAI,CAACE,IAAL,CAAUuR,UAAV,GAAuB,IAAvB;gBACH,CAJD,MAKK;kBACD;kBACAzR,IAAI,CAACE,IAAL,CAAU,UAAV,IAAwB,KAAKyU,WAAL,CAAiB3U,IAAI,CAACgE,MAAtB,EAA8BuN,KAA9B,EAAqC0E,YAArC,CAAxB;gBACH;;gBACD;cACH;;cACD,MAAM,IAAItY,KAAJ,CAAU,qDAAqDqC,IAAI,CAACqD,MAApE,CAAN;UAvCR;;UAyCA;;QACJ,KAAK,WAAL;UACIrD,IAAI,GAAG2D,QAAQ,CAACpD,YAAT,CAAsB8D,MAAtB,EAA8BrE,IAA9B,CAAP;UACA;MAhER;;MAkEA,OAAOA,IAAP;IACH;;IACDmE,YAAY,CAACR,QAAD,EAAW3B,OAAX,EAAoBqC,MAApB,EAA4BrE,IAA5B,EAAkC;MAC1C,QAAQA,IAAI,CAACqD,MAAb;QACI,KAAK,YAAL;QACA,KAAK,uBAAL;QACA,KAAK,6BAAL;QACA,KAAK,0BAAL;UACI,OAAO,KAAKyR,aAAL,CAAmB9U,IAAI,CAACE,IAAL,CAAU,UAAV,CAAnB,CAAP;;QACJ,KAAK,aAAL;UACI,OAAO,KAAK8U,cAAL,CAAoBhV,IAAI,CAACE,IAAL,CAAU,UAAV,CAApB,CAAP;;QACJ;UACI;UACA;UACA,MAAM6V,eAAe,GAAG,KAAKC,mBAAL,CAAyBhW,IAAzB,CAAxB;;UACA,IAAI+V,eAAJ,EAAqB;YACjB,MAAMG,QAAQ,GAAGlW,IAAI,CAACE,IAAL,CAAU,UAAV,CAAjB;YACA,OAAO6V,eAAe,CAACtE,UAAhB,GAA6B,KAAKuD,cAAL,CAAoBkB,QAApB,CAA7B,GACH,KAAKpB,aAAL,CAAmBoB,QAAnB,CADJ;UAEH;;UACD,OAAOvS,QAAQ,CAACS,UAAT,CAAoBC,MAApB,EAA4BrE,IAA5B,CAAP;MAjBR;IAmBH;;IACD6D,QAAQ,CAACF,QAAD,EAAW3B,OAAX,EAAoBqC,MAApB,EAA4B8R,QAA5B,EAAsCrS,SAAtC,EAAiDC,SAAjD,EAA4DV,MAA5D,EAAoE;MACxE,IAAI;QACAyE,qBAAqB,CAACqN,SAAtB;QACA,OAAOxR,QAAQ,CAACK,MAAT,CAAgBK,MAAhB,EAAwB8R,QAAxB,EAAkCrS,SAAlC,EAA6CC,SAA7C,EAAwDV,MAAxD,CAAP;MACH,CAHD,SAIQ;QACJ,IAAI,CAAC,KAAK0Q,eAAV,EAA2B;UACvBjM,qBAAqB,CAACuN,SAAtB;QACH;MACJ;IACJ;;IACDW,mBAAmB,CAAChW,IAAD,EAAO;MACtB,IAAI,CAAC,KAAKwT,gBAAV,EAA4B;QACxB,OAAO,IAAP;MACH;;MACD,KAAK,IAAInV,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKmV,gBAAL,CAAsBlV,MAA1C,EAAkDD,CAAC,EAAnD,EAAuD;QACnD,MAAM0X,eAAe,GAAG,KAAKvC,gBAAL,CAAsBnV,CAAtB,CAAxB;;QACA,IAAI0X,eAAe,CAAC1S,MAAhB,KAA2BrD,IAAI,CAACqD,MAApC,EAA4C;UACxC,OAAO0S,eAAP;QACH;MACJ;;MACD,OAAO,IAAP;IACH;;IACDvV,aAAa,CAACX,kBAAD,EAAqBC,WAArB,EAAkCC,UAAlC,EAA8CzC,KAA9C,EAAqD;MAC9D,KAAKqW,UAAL,GAAkBrW,KAAlB;MACA,OAAO,KAAP,CAF8D,CAEhD;IACjB;;EA7UuB,CAhPb,CA+jBf;EACA;;;EACAgC,IAAI,CAAC,uBAAD,CAAJ,GAAgCwI,qBAAhC;AACH,CAlkBD,EAkkBG,OAAO+H,MAAP,KAAkB,QAAlB,IAA8BA,MAA9B,IAAwC,OAAOtD,IAAP,KAAgB,QAAhB,IAA4BA,IAApE,IAA4E3H,MAlkB/E;;AAmkBAtF,IAAI,CAACqF,YAAL,CAAkB,WAAlB,EAA+B,CAACC,MAAD,EAAStF,IAAT,EAAeuF,GAAf,KAAuB;EAClD,MAAMiD,qBAAqB,GAAGxI,IAAI,IAAIA,IAAI,CAAC,uBAAD,CAA1C;;EACA,SAAS8W,gBAAT,GAA4B;IACxB,OAAO9W,IAAI,IAAIA,IAAI,CAAC,eAAD,CAAnB;EACH;;EACD,IAAI+W,sBAAsB,GAAG,IAA7B;EACA;AACJ;AACA;AACA;AACA;AACA;;EACI,SAASC,kBAAT,GAA8B;IAC1B,IAAID,sBAAJ,EAA4B;MACxBA,sBAAsB,CAACd,eAAvB;IACH;;IACDc,sBAAsB,GAAG,IAAzB,CAJ0B,CAK1B;;IACAD,gBAAgB,MAAMA,gBAAgB,GAAGlU,aAAnB,GAAmCU,aAAnC,EAAtB;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACI,SAASyG,SAAT,CAAmBM,EAAnB,EAAuB;IACnB;IACA,MAAM4M,WAAW,GAAG,UAAU,GAAGtO,IAAb,EAAmB;MACnC,MAAM3G,aAAa,GAAG8U,gBAAgB,EAAtC;;MACA,IAAI,CAAC9U,aAAL,EAAoB;QAChB,MAAM,IAAI3D,KAAJ,CAAU,iFACZ,uEADE,CAAN;MAEH;;MACD,MAAM0M,aAAa,GAAG/I,aAAa,CAACY,aAAd,EAAtB;;MACA,IAAI5C,IAAI,CAAC0C,OAAL,CAAaD,GAAb,CAAiB,uBAAjB,CAAJ,EAA+C;QAC3C,MAAM,IAAIpE,KAAJ,CAAU,qCAAV,CAAN;MACH;;MACD,IAAI;QACA;QACA,IAAI,CAAC0Y,sBAAL,EAA6B;UACzB,IAAIhM,aAAa,CAAC1H,WAAd,cAAuCmF,qBAA3C,EAAkE;YAC9D,MAAM,IAAInK,KAAJ,CAAU,qCAAV,CAAN;UACH;;UACD0Y,sBAAsB,GAAG,IAAIvO,qBAAJ,EAAzB;QACH;;QACD,IAAI0O,GAAJ;QACA,MAAMC,iBAAiB,GAAGpM,aAAa,CAAC1H,WAAd,EAA1B;QACA0H,aAAa,CAACvI,WAAd,CAA0BuU,sBAA1B;;QACAA,sBAAsB,CAACf,aAAvB;;QACA,IAAI;UACAkB,GAAG,GAAG7M,EAAE,CAACrD,KAAH,CAAS,IAAT,EAAe2B,IAAf,CAAN;UACAwE,eAAe;QAClB,CAHD,SAIQ;UACJpC,aAAa,CAACvI,WAAd,CAA0B2U,iBAA1B;QACH;;QACD,IAAIJ,sBAAsB,CAACxC,qBAAvB,CAA6CvV,MAA7C,GAAsD,CAA1D,EAA6D;UACzD,MAAM,IAAIX,KAAJ,CAAW,GAAE0Y,sBAAsB,CAACxC,qBAAvB,CAA6CvV,MAAO,GAAvD,GACX,uCADC,CAAN;QAEH;;QACD,IAAI+X,sBAAsB,CAACvC,aAAvB,CAAqCxV,MAArC,GAA8C,CAAlD,EAAqD;UACjD,MAAM,IAAIX,KAAJ,CAAW,GAAE0Y,sBAAsB,CAACvC,aAAvB,CAAqCxV,MAAO,+BAAzD,CAAN;QACH;;QACD,OAAOkY,GAAP;MACH,CA3BD,SA4BQ;QACJF,kBAAkB;MACrB;IACJ,CAzCD;;IA0CAC,WAAW,CAACnL,WAAZ,GAA0B,IAA1B;IACA,OAAOmL,WAAP;EACH;;EACD,SAASG,qBAAT,GAAiC;IAC7B,IAAIL,sBAAsB,IAAI,IAA9B,EAAoC;MAChCA,sBAAsB,GAAG/W,IAAI,CAAC0C,OAAL,CAAaD,GAAb,CAAiB,uBAAjB,CAAzB;;MACA,IAAIsU,sBAAsB,IAAI,IAA9B,EAAoC;QAChC,MAAM,IAAI1Y,KAAJ,CAAU,wEAAV,CAAN;MACH;IACJ;;IACD,OAAO0Y,sBAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACI,SAAS7O,IAAT,CAAckL,MAAM,GAAG,CAAvB,EAA0BiE,mBAAmB,GAAG,KAAhD,EAAuD;IACnDD,qBAAqB,GAAGlP,IAAxB,CAA6BkL,MAA7B,EAAqC,IAArC,EAA2CiE,mBAA3C;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACI,SAASjK,KAAT,CAAekK,QAAf,EAAyB;IACrB,OAAOF,qBAAqB,GAAGhK,KAAxB,CAA8BkK,QAA9B,CAAP;EACH;EACD;AACJ;AACA;AACA;AACA;;;EACI,SAASC,oBAAT,GAAgC;IAC5B,MAAMrT,QAAQ,GAAGkT,qBAAqB,EAAtC;;IACAlT,QAAQ,CAACqQ,qBAAT;IACArQ,QAAQ,CAACqQ,qBAAT,CAA+BvV,MAA/B,GAAwC,CAAxC;EACH;EACD;AACJ;AACA;AACA;AACA;;;EACI,SAASmO,eAAT,GAA2B;IACvBiK,qBAAqB,GAAGjK,eAAxB;EACH;;EACDnN,IAAI,CAACuF,GAAG,CAACY,MAAJ,CAAW,eAAX,CAAD,CAAJ,GACI;IAAE6Q,kBAAF;IAAsB7J,eAAtB;IAAuCoK,oBAAvC;IAA6DrP,IAA7D;IAAmEkF,KAAnE;IAA0ErD;EAA1E,CADJ;AAEH,CA9ID,EA8IG,IA9IH;AAgJA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA/J,IAAI,CAACqF,YAAL,CAAkB,gBAAlB,EAAoC,CAACC,MAAD,EAAStF,IAAT,EAAeuF,GAAf,KAAuB;EACvD,MAAMiS,WAAW,GAAGjS,GAAG,CAACY,MAAJ,CAAW,OAAX,CAApB;EACA,MAAMsR,UAAU,GAAG,IAAnB;EACA,MAAMtH,sBAAsB,GAAG5K,GAAG,CAACY,MAAJ,CAAW,kBAAX,CAA/B,CAHuD,CAIvD;EACA;EACA;EACA;EACA;EACA;EACA;;EACA8J,OAAO,CAAC1K,GAAG,CAACY,MAAJ,CAAW,qBAAX,CAAD,CAAP,GAA6C,SAAS6J,mBAAT,GAA+B;IACxE,IAAI0H,OAAO,GAAGzH,OAAO,CAACjQ,IAAI,CAACK,UAAL,CAAgB,iBAAhB,CAAD,CAArB;;IACA,IAAIqX,OAAJ,EAAa;MACT;IACH;;IACDA,OAAO,GAAGzH,OAAO,CAACjQ,IAAI,CAACK,UAAL,CAAgB,iBAAhB,CAAD,CAAP,GAA8C4P,OAAO,CAACpK,SAAR,CAAkB8R,IAA1E;;IACA1H,OAAO,CAACpK,SAAR,CAAkB8R,IAAlB,GAAyB,YAAY;MACjC,MAAMC,OAAO,GAAGF,OAAO,CAAC1Q,KAAR,CAAc,IAAd,EAAoBC,SAApB,CAAhB;;MACA,IAAI,KAAKuQ,WAAL,MAAsBC,UAA1B,EAAsC;QAClC;QACA,MAAMI,iBAAiB,GAAG7X,IAAI,CAAC0C,OAAL,CAAaD,GAAb,CAAiB,mBAAjB,CAA1B;;QACA,IAAIoV,iBAAJ,EAAuB;UACnBA,iBAAiB,CAACjI,6BAAlB;UACAgI,OAAO,CAACzH,sBAAD,CAAP,GAAkC,IAAlC;QACH;MACJ;;MACD,OAAOyH,OAAP;IACH,CAXD;EAYH,CAlBD;;EAmBA3H,OAAO,CAAC1K,GAAG,CAACY,MAAJ,CAAW,uBAAX,CAAD,CAAP,GAA+C,SAAS2R,qBAAT,GAAiC;IAC5E;IACA,MAAMJ,OAAO,GAAGzH,OAAO,CAACjQ,IAAI,CAACK,UAAL,CAAgB,iBAAhB,CAAD,CAAvB;;IACA,IAAIqX,OAAJ,EAAa;MACTzH,OAAO,CAACpK,SAAR,CAAkB8R,IAAlB,GAAyBD,OAAzB;MACAzH,OAAO,CAACjQ,IAAI,CAACK,UAAL,CAAgB,iBAAhB,CAAD,CAAP,GAA8CD,SAA9C;IACH;EACJ,CAPD;AAQH,CAtCD"},"metadata":{},"sourceType":"script"}